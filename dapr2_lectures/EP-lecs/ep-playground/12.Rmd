---
title: "12 Playground – Interactions num num"
output: html_notebook
---

```{r setup}
library(tidyverse)
library(interactions)  # for probe_interactions() plot

salary <- read_csv("../../data/salary2.csv", show_col_types = FALSE)

# palette_probe <- c('#4ab8fc', '#ff7b01')
```


# Plot data

```{r}
salary |>
  mutate() |>
  ggplot(aes(x = serv, y = salary, colour = perf, size = perf)) +
  geom_point()
```

## Facet by perf


```{r}
salary |>
  mutate() |>
  ggplot(aes(x = serv, y = salary)) +
  geom_point() +
  geom_smooth(method = 'lm', se = F) +
  facet_wrap(~ factor(perf), nrow=1)
```

Slopes over `serv` are different at different levels of `perf`.
In particular, slopes over `serv` get more positive as `perf` gets larger.

Hard to plot the symmetrical interaction in the data, because we don't have the plane yet that we slice to get each of the lines.


# Fit asis model

```{r}
m1 <- lm(salary ~ serv * perf, data = salary)
summary(m1)
```

```{r}
m1_probe <- probe_interaction(
  m1,
  pred = serv,
  modx = perf,
  cond.int = T,
  interval = T,
  jnplot = T
)
```


```{r}
m1_probe$interactplot
```

## Simple slopes sig test

Gives both a pretty-printed simple slopes analysis and the johnson-neyman plot.

```{r}
m1_probe$simslopes
```


```{r}
m1_probe$simslopes$slopes
```


```{r}
m1_probe$simslopes$jnplot
```

JN plot illustrates:
- At which levels of performance (x axis) is the slope of the line that associates `serv` with `salary` significantly different from zero?
- **At which levels of performance (x axis) do years of service (serv, not on plot) significantly predict salary (not on plot)?**


- when performance is less than like 1.8: 
  - then the slope of service is significantly different from zero (and negative)
- and when performance is above like 4.3: 
  - then the slope of service is significantly different from zero (and positive)
  
OK, put this plot on the same slide as the plot of the data at each level of `perf`, and draw lines to connect.



## Simple slopes by hand

```{r}
coef(m1)
```


$$
\begin{align}
\widehat{salary} &= \beta_0 + (\beta_1 \cdot serv) + (\beta_2 \cdot perf) + (\beta_3 \cdot serv \cdot perf)\\
\widehat{salary} &= 87.9    + (-10.9 \cdot serv)     + (3.2 \cdot perf)    + (3.3 \cdot serv \cdot perf)\\
\end{align}
$$

(working-out with bad rounding on p. 31 of book)


### For perfs 0 thru 7

When perf = 0:

```{r}
coef(m1)[['(Intercept)']]  # intercept
coef(m1)[['serv']]      # slope
```


When perf = 1:

```{r}
coef(m1)[['(Intercept)']] + coef(m1)[['perf']]      # intercept
coef(m1)[['serv']] + coef(m1)[['serv:perf']]  # slope
```


When perf = 7:

```{r}
coef(m1)[['(Intercept)']] + (7 * coef(m1)[['perf']]) # intercept
coef(m1)[['serv']] + (7 * coef(m1)[['serv:perf']])   # slope
```


### For perfs -1SD, mean, +1SD

```{r}
(meanperf <- mean(salary$perf))
(lowerperf <- meanperf - sd(salary$perf))
(upperperf <- meanperf + sd(salary$perf))
```

When perf is at its mean – 1 SD:

```{r}
coef(m1)[['(Intercept)']] + (lowerperf * coef(m1)[['perf']]) # intercept
coef(m1)[['serv']] + (lowerperf * coef(m1)[['serv:perf']])   # slope
```

When perf is at its mean:

```{r}
coef(m1)[['(Intercept)']] + (meanperf * coef(m1)[['perf']]) # intercept
coef(m1)[['serv']] + (meanperf * coef(m1)[['serv:perf']])   # slope
```


When perf is at its mean + 1 SD:

```{r}
coef(m1)[['(Intercept)']] + (upperperf * coef(m1)[['perf']]) # intercept
coef(m1)[['serv']] + (upperperf * coef(m1)[['serv:perf']])   # slope
```


Those lines match the ones generated by `probe_interaction()`.



# Centre both predictors

```{r}
salary <- salary |>
  mutate(
    serv_c = scale(serv, center = TRUE, scale = FALSE),
    perf_c = scale(perf, center = TRUE, scale = FALSE),
  )

m2 <- lm(salary ~ serv_c * perf_c, data = salary)
summary(m2)
```


```{r}
m2_probe <- probe_interaction(
  m2,
  pred = serv_c,
  modx = perf_c,
  cond.int = T,
  interval = T,
  jnplot = T
)
```


```{r}
m2_probe$interactplot
```

## Simple slopes sig test

Gives both a pretty-printed simple slopes analysis and the johnson-neyman plot.

```{r}
m2_probe$simslopes
```


```{r}
m2_probe$simslopes$slopes
```


```{r}
m2_probe$simslopes$jnplot
```



## symmetrical probe

```{r}
probe_interaction(
  m2,
  pred = perf_c,
  modx = serv_c,
  cond.int = T,
  interval = T,
  jnplot = T
)$interactplot
```

Can flip the interpretation




# Appendix

- all simple slope calculations for all models

