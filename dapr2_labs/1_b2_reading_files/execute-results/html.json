{
  "hash": "cdbe8ad33df49cad4ddbc9920c0a60ed",
  "result": {
    "markdown": "---\ntitle: \"Block 1 & 2 Flash Cards\"\nlink-citations: true\ncode-annotations: hover\nparams: \n    SHOW_SOLS: TRUE\n    TOGGLE: TRUE\neditor_options: \n  chunk_output_type: inline\n---\n\n\n\n\n:::lo\n\n### <i class=\"fab fa-r-project\"></i> R Packages\n\nWithin this reading, the following packages are used:\n\n* **tidyverse** \n* **sjPlot**\n* **kableExtra**\n* **psych**\n* **patchwork**\n* **plotly**\n\n### <i class=\"fa fa-pencil-square-o\" aria-hidden=\"true\"></i> Presenting Results\nNote that you must **not** copy any of the write-ups included below for future reports - if you do, you will be committing plagiarism, and this type of academic misconduct is taken very seriously by the University. You can find out more [here](https://www.ed.ac.uk/academic-services/students/conduct/academic-misconduct).\n\n:::\n\n# Back to Basics\n\nFor an overview of basic statistical tests and core concepts (e.g., $p$-values), please revisit the [DAPR1 materials](https://uoepsy.github.io/dapr1/2425/) for a refresher (also accessible via the DAPR1 Learn page).\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-1' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-1', 'opt-start-1')\"> <span class=\"olab\">Terminology</span></span></div><div class=\"optional-body\" id = \"opt-body-1\" style=\"display: none;\">\n\n\n\nLet's spend some time to remind ourselves of some key terminology, specifically related to types of variables and study designs:\n\n\n| Term           | Definition       |\n|----------------|------------------|\n| (Observational) unit | The individual entities on which data are collected |  \n| Variable | Any characteristic recorded on the observational units |  \n| Numeric variable | A variable that records a numerical quantity for each case. For such variables standard arithmetic operations make sense. For example: height, IQ, and weight |  \n| Categorical variable | A categorical variable places units into one of several groups. For example: country of birth, dominant hand, and eye colour |  \n| Binary variable | A special case of categorical variable with only 2 possible levels. For example: handedness (left or right), smoking status (smoker or non-smoker), pass test (yes or no) |  \n| Response variable (also more commonly called a dependent variable, or outcome variable) | Measures the outcome of interest in a study |  \n| Explanatory/independent variable (also called predictors) | Are used to explain differences/changes in the response variable |  \n| Observational study | An observational study is a study in which the researcher does not manipulate any of the variables involved in the study, but merely records the values as they naturally exist | \n| Experimental study | An experiment is a study in which the researcher imposes the values of the explanatory variable on the units before measuring the response variable |  \n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Data Exploration\n\nThe common first port of call for almost any statistical analysis is to explore the data, and we can do this visually and/or numerically.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-2' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-2', 'opt-start-2')\"> <span class=\"olab\">Marginal Distributions & Bivariate Associations</span></span></div><div class=\"optional-body\" id = \"opt-body-2\" style=\"display: none;\">\n\n\n\n<table cellspacing=\"3\">\n<tr style=\"border-bottom: 1px solid\"><th></th><th style=\"border-right: 1px solid\">Marginal Distributions</th><th>Bivariate Associations</th></tr>\n<tr style=\"border-bottom: 1px solid\">\n<td style=\"vertical-align:top\">**Description**</td>\n<td style=\"vertical-align:top;border-right: 1px solid\">The distribution of each variable individually (i.e., *without* reference to the values of the other variables).</td>\n<td style=\"vertical-align:top\">Describing the association between two numeric variables.</td>\n</tr>\n<tr style=\"border-bottom: 1px solid\">\n<td style=\"vertical-align:top\">**Visually**</td>\n<td style=\"vertical-align:top;border-right: 1px solid\">Plot each variable individually.<br><br>You could use, for example, `geom_density()` for a density plot or `geom_histogram()` for a histogram to comment on and/or examine:<br><ul><li> The *shape* of the distribution. Look at the shape, centre and spread of the distribution. Is it symmetric or skewed? Is it unimodal or bimodal? </li><li> Identify any *unusual observations*. Do you notice any extreme observations (i.e., outliers)? </li></ul></td>\n<td style=\"vertical-align:top\">Plot associations among two variables.<br><br>You could use, for example, `geom_point()` for a scatterplot  to comment on and/or examine:<br><ul><li>The *direction* of the association indicates whether there is a positive or negative association</li><li>The *form* of association refers to whether the relationship between the variables can be summarized well with a straight line or some more complicated pattern </li><li>The *strength* of association entails how closely the points fall to a recognizable pattern such as a line  </li><li>*Unusual observations* that do not fit the pattern of the rest of the observations and which are worth examining in more detail </li></ul></td>\n</tr>\n<tr style=\"border-bottom: 1px solid\">\n<td style=\"vertical-align:top\">**Numerically**&nbsp;&nbsp;&nbsp;</td>\n<td style=\"vertical-align:top;border-right: 1px solid\">Compute and report summary statistics e.g., mean, standard deviation, median, min, max, etc.<br><br>You could, for example, calculate summary statistics such as the mean (`mean()`) and standard deviation (`sd()`), etc. within `summarize()`</td>\n<td style=\"vertical-align:top\">Compute and report the correlation coefficient.<br><br>You can use the `cor()` function to calculate this</td>\n</tr>\n</table>\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Numeric Exploration\n\nNumeric exploration of data involves examining and describing key statistics like mean, median, and standard deviation via descriptives tables; and assessing the associations among variables through correlation coefficients. Exploring our data numerically helps us to identify patterns and associations in the data. When doing so, it is important to contextualise the descriptive statistics within the scope of the research question and associated scales. \n\n### Descriptives \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-3' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-3', 'opt-start-3')\"> <span class=\"olab\">Descriptives Tables</span></span></div><div class=\"optional-body\" id = \"opt-body-3\" style=\"display: none;\">\n\n\n\nThere are numerous packages available that allow us to pull out descriptive statistics from our dataset such as **tidyverse** and **psych**.\n\nWhen we pull out descriptive statistics, it is useful to present these in a well formatted table for your reader. There are lots of different ways of doing this, but one of the most common (and straightforward!) is to use the `kable()` function from the package **kableExtra**. \n\nThis allows us to give our table a clear caption (via `caption = \"insert caption here\"`, align values within columns e.g., center aligned via `align = \"??\"`), and we can also round to however many decimal places we desire (standard for APA is 2 dp; via `digits = ??`). \n\nWe can also add in the function `kable_styling()`. This is really helpful for customsing your table e.g., the font size, position, and whether or not you want the table full width (as well as lots of other things - check out the helper function!). \n\nFor an overview of how to make tables in RMarkdown, see [Lesson 4 of the RMD bootcamp](https://uoepsy.github.io/scs/rmd-bootcamp/04-prettytab.html).\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-4' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-4', 'opt-start-4')\"> <span class=\"olab\">Descriptives Tables - Examples</span></span></div><div class=\"optional-body\" id = \"opt-body-4\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n##### The **tidyverse** way\n\nWe can use the `summarise()` function to numerically summarise/describe our data. Some key values we may want to consider extracting are (though not limited to): the mean (via `mean()`, standard deviation (via `sd()`), minimum value (via `min()`), maximum value (via `max()`), standard error (via `se()`), and skewness (via `skew()`). \n\n::: {.panel-tabset}\n\n## Numeric values only example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(kableExtra)\n\n# using the pre-loaded iris dataset\n# taking the mean and standard deviation of sepal length via the summarize function\n# returning a table with a caption, where numbers are rounded to 2 dp\n# asking for a table that is not the full width of the window display\niris |>\n    summarize(\n        M_Length = mean(Sepal.Length),\n        SD_Length = sd(Sepal.Length)\n    ) |>\n    kable(caption = \"Sepal Length Descriptives (in cm)\", digits = 2) |>\n    kable_styling(full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Sepal Length Descriptives (in cm)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> M_Length </th>\n   <th style=\"text-align:right;\"> SD_Length </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 5.84 </td>\n   <td style=\"text-align:right;\"> 0.83 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Categorical and numeric values example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(kableExtra)\n\n# using the pre-loaded iris dataset\n# grouping by Species. NOTE: we can group by 2 variables - we would just separate by a comma within group_by( , )\n# taking the mean and standard deviation of sepal length via the summarize function\n# returning a table of sepal length grouped by species with a caption, where numbers are rounded to 2 dp\n# asking for a table that is not the full width of the window display\n\niris |>\n    group_by(Species) |>\n    summarize(\n        M_Length = mean(Sepal.Length),\n        SD_Length = sd(Sepal.Length)\n    ) |>\n    kable(caption = \"Sepal Length (in cm) Grouped by Species Descriptives Table\", digits = 2) |>\n    kable_styling(full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Sepal Length (in cm) Grouped by Species Descriptives Table</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Species </th>\n   <th style=\"text-align:right;\"> M_Length </th>\n   <th style=\"text-align:right;\"> SD_Length </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> setosa </td>\n   <td style=\"text-align:right;\"> 5.01 </td>\n   <td style=\"text-align:right;\"> 0.35 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> versicolor </td>\n   <td style=\"text-align:right;\"> 5.94 </td>\n   <td style=\"text-align:right;\"> 0.52 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> virginica </td>\n   <td style=\"text-align:right;\"> 6.59 </td>\n   <td style=\"text-align:right;\"> 0.64 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n:::\n\n##### The **psych** way\n\nThe `describe()` function will produce a table of descriptive statistics. If you would like only a subset of this output (e.g., mean, sd), you can use `select()` after calling `describe()` e.g., `describe() |> select(mean, sd)`.\n\n::: {.panel-tabset}\n\n## Numeric values only example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(psych)\nlibrary(kableExtra)\n\n# using the pre-loaded iris dataset\n# we want to get descriptive statistics of the iris dataset, specifically the sepal length column\n# we specifically want to select the mean and standard deviation from the descriptive statistics available (try this without including this argument to see what values you all get out)\n# returning a table with a caption, where numbers are rounded to 2 dp\n# asking for a table that is not the full width of the window display\ndescribe(iris$Sepal.Length) |>\n    select(mean, sd) |>\n    kable(caption = \"Sepal Length Descriptives (in cm)\", digits = 2) |>\n    kable_styling(full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Sepal Length Descriptives (in cm)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:right;\"> mean </th>\n   <th style=\"text-align:right;\"> sd </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> X1 </td>\n   <td style=\"text-align:right;\"> 5.84 </td>\n   <td style=\"text-align:right;\"> 0.83 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Categorical and numeric values options:\n\n*Note that this is quite an overly complex way to return these summary statistics - using the `tidyverse()` way is much more intuitive and straightforward!*\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(psych)\nlibrary(kableExtra)\n\n# using the pre-loaded iris dataset\n# we want to get descriptive statistics of the iris dataset, specifically the sepal length column by Species\n# we want to return a matrix (hence mat = TRUE), then convert this to a dataframe\n# we specifically want to select the mean and standard deviation from the descriptive statistics available (try this without including this argument to see what values you all get out)\n# returning a table with a new column names of Group, Mean, SD; adding a caption; numbers are rounded to 2 dp\n# asking for a table that is not the full width of the window display\n\n\ndescribeBy(Sepal.Length ~ Species, data = iris, mat = TRUE, digits = 2) |>\n  as.data.frame() |>\n  rownames_to_column() |> \n  select(group1, mean, sd) |>\n    kable(col.names = c(\"Group\", \"Mean\", \"SD\"), caption = \"Sepal Length Descriptives (in cm)\", digits = 2) |>\n    kable_styling(full_width = FALSE)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Sepal Length Descriptives (in cm)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Group </th>\n   <th style=\"text-align:right;\"> Mean </th>\n   <th style=\"text-align:right;\"> SD </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> setosa </td>\n   <td style=\"text-align:right;\"> 5.01 </td>\n   <td style=\"text-align:right;\"> 0.35 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> versicolor </td>\n   <td style=\"text-align:right;\"> 5.94 </td>\n   <td style=\"text-align:right;\"> 0.52 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> virginica </td>\n   <td style=\"text-align:right;\"> 6.59 </td>\n   <td style=\"text-align:right;\"> 0.64 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n#### Correlation\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-5' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-5', 'opt-start-5')\"> <span class=\"olab\">Correlation Coefficient</span></span></div><div class=\"optional-body\" id = \"opt-body-5\" style=\"display: none;\">\n\n\n\nThe correlation coefficient - $r_{(x,y)}=\\frac{\\mathrm{cov}(x,y)}{s_xs_y}$ - is a standardised number which quantifies the strength and direction of the linear association between two variables. In a population it is denoted by $\\rho$, and in a sample it is denoted by $r$. \n\nValues of $r$ fall between $-1$ and $1$. How to interpret:\n\n###### Size\n\nMore extreme values (i.e., the The closer $r$ is to $+/- 1$) the stronger the linear association, and the closer to $0$ a weak/no association. Commonly used cut-offs are:   \n  \n+ Weak = $.1 < |r| < .3$  \n+ Moderate = $.3 < |r| < .5$  \n+ Strong = $|r| > .5$  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n###### Direction\n\nThe sign of $r$ says nothing about the strength of the association, but its nature and direction:  \n  \n+ Positive association means that values of one variable tend to be higher when values of the other variable are higher \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n+ Negative association means that values of one variable tend to be lower when values of the other variable are higher  \n    \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-6' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-6', 'opt-start-6')\"> <span class=\"olab\">Correlation Matrix</span></span></div><div class=\"optional-body\" id = \"opt-body-6\" style=\"display: none;\">\n\n\n\nA correlation matrix is a table showing the correlation coefficients between variables. Each cell in the table shows the association between two variables. The diagonals show the correlation of a variable with itself (and are therefore always equal to 1).  \n\n:::blue\n**In R**\n\nWe can create a correlation matrix by giving the `cor()` function a dataframe. It is important to remember that all variables **must** be numeric. One way to check this is by using the `str()` argument. \n\n:::\n\nLet's check the structure of the iris dataset to ensure that all variables are numeric:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n:::\n\n\nWe can see that the variable *Species* in column 5 is a factor - this means that we cannot include this in our correlation matrix. Therefore, we need to *subset*, or, in other words, select specific columns. We can do this either giving the column numbers inside `[]`, or using `select()`. In our case, we want the variables in columns 1 - 4, just not 5.\n\nIf you had `NA` values within your dataset, you could choose to remove these `NA`s using `na.rm = TRUE` inside the `cor()` function.  \n\n:::blue\n**In R**\n\n::: {.panel-tabset}\n\n## Index dataframe (`[]`)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nround(cor(iris[,c(1:4)]), digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Sepal.Length Sepal.Width Petal.Length Petal.Width\nSepal.Length         1.00       -0.12         0.87        0.82\nSepal.Width         -0.12        1.00        -0.43       -0.37\nPetal.Length         0.87       -0.43         1.00        0.96\nPetal.Width          0.82       -0.37         0.96        1.00\n```\n:::\n:::\n\n\n## Variable selection (`select()`)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# select only the columns we want by variable name, and pass this to cor()\niris |> \n  select(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) |>\n  cor() |>\n  round(digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             Sepal.Length Sepal.Width Petal.Length Petal.Width\nSepal.Length         1.00       -0.12         0.87        0.82\nSepal.Width         -0.12        1.00        -0.43       -0.37\nPetal.Length         0.87       -0.43         1.00        0.96\nPetal.Width          0.82       -0.37         0.96        1.00\n```\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-7' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-7', 'opt-start-7')\"> <span class=\"olab\">Correlation - Hypothesis Testing</span></span></div><div class=\"optional-body\" id = \"opt-body-7\" style=\"display: none;\">\n\n\n\nThe hypotheses of the correlation test are, as always, statements about the _population_ parameter (in this case the correlation between the two variables in the population - i.e., $\\rho$).  \n\nIf we are conducting a two tailed test, then... \n\n- $H_0: \\rho = 0$. There is _no_ linear association between $x$ and $y$ in the population  \n- $H_1: \\rho \\neq 0$ There is a linear association between $x$ and $y$  \n  \nIf we instead conduct a one-tailed test, then we are testing either...\n\n- $H_0: \\rho \\leq 0$ There is a negative or no linear association between $x$ and $y$   \n- $H_1: \\rho > 0$ There is a positive linear association between $x$ and $y$\n\n**OR**\n\n- $H_0: \\rho \\geq 0$ There is a positive or no linear association between $x$ and $y$   \n- $H_1: \\rho < 0$ There is a negative linear association between $x$ and $y$  \n\n__Test Statistic__  \n\nThe  test statistic for this test is the $t$ statistic, the formula for which depends on both the observed correlation ($r$) and the sample size ($n$):\n\n$$t = r \\sqrt{\\frac{n-2}{1-r^2}}$$\n\n\n__p-value__  \n\nWe calculate the $p$-value for our $t$-statistic as the long-run probability of a $t$-statistic with $n-2$ degrees of freedom being less than, greater than, or more extreme in either direction (depending on the direction of our alternative hypothesis) than our observed $t$-statistic.  \n\n__Assumptions__  \n\nFor a test of Pearson's correlation coefficient $r$, we need to make sure a few conditions are met:  \n  \n+ Both variables are quantitative (i.e., continuous)  \n+ Both variables are drawn from normally distributed populations  \n+ The association between the two variables is linear    \n+ No extreme outliers in dataset    \n+ Homoscedasticity (homogeneity of variance)  \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-8' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-8', 'opt-start-8')\"> <span class=\"olab\">Correlation - Hypothesis Testing in R</span></span></div><div class=\"optional-body\" id = \"opt-body-8\" style=\"display: none;\">\n\n\n\n:::blue\n**In R**\n\nWe can test the significance of the correlation coefficient really easily with the function `cor.test()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncor.test(iris$Sepal.Length, iris$Petal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tPearson's product-moment correlation\n\ndata:  iris$Sepal.Length and iris$Petal.Length\nt = 21.646, df = 148, p-value < 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8270363 0.9055080\nsample estimates:\n      cor \n0.8717538 \n```\n:::\n:::\n\n\nNote, by default, `cor.test()` will include only observations that have no missing data on either variable. \n\nWe can specify whether we want to conduct a one- or two-tailed test by adding the argument `alternative = ` and specifying `alternative = \"less\"`, `alternative = \"greater\"`, or `alternative = \"two.sided\"` (the latter being the default).  \n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nThere was a strong positive association between sepal length and petal length $(r = .87, t(148) = 21.65, p < .001)$. These results suggested that a greater sepal length was positively associated with a greater petal length. \n\n:::\n\n:::{.callout-note}\n\nFor a detailed recap of all things correlation (including further details and examples), revisit the [Correlation lecture from DAPR1](https://uoepsy.github.io/dapr1/2425/lectures/dapR1_lec20_correlation.pdf).\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Visual Exploration\n\nVisual exploration of our data allows us to visualize the distributions of our data, and to identify potential associations among variables.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-9' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-9', 'opt-start-9')\"> <span class=\"olab\">How to Visualise Data</span></span></div><div class=\"optional-body\" id = \"opt-body-9\" style=\"display: none;\">\n\n\n\nTo visualise (i.e., plot) our data, we can use `ggplot()` from the **tidyverse** package. Note the key components of the `ggplot()` code:\n\n+ `data =` where we provide the name of the dataframe\n+ `aes =` where we provide the aesthetics. These are things which we map from the data to the graph. For instance, the $x$-axis, or if we wanted to colour the columns/bars according to some aspect of the data\n+ `+ geom_...` = where we add (using `+`) some geometry. These are the shapes (e.g., bars, points, etc.), which will be put in the correct place according to what we specified in `aes()`  \n+ `labs()` = where we provide labels for our plot (e.g., the $x$- and $y$-axis)\n\n:::{.callout-note}\n\nThere are lots of arguments that you can further customise, some of which are specified in the examples below e.g., `bins = `, `alpha = `, `fill = `, `linewidth = `. `linetype = `, `size = ` etc. For these, you can look up the helper function to see the range of arguments they can take using `?` - e.g., `?fill`.\n\nIf you'd like to read more about `ggplot()`, there is a handy [cheatsheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf).\n\n:::\n\nOne other thing to consider when visualising your data is how you are going to arrange your plots. Some handy tips on this:  \n  \n- Use \\n to wrap text in your titles and or axis labels  \n- The **patchwork** package allows us to arrange multiple plots in two ways - `|` arranges the plots adjacent to one another, and `/` arranges the plots on top of one another  \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-10' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-10', 'opt-start-10')\"> <span class=\"olab\">Marginal Distributions - Examples</span></span></div><div class=\"optional-body\" id = \"opt-body-10\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n#### Histogram\n\nA histogram shows the frequency of values which fall within bins of an equal width. \n\n**Basic:**\n\n- x-axis: possible values of some variable, grouped into bins\n- y-axis: frequency of a given value or values within bins\n- *What are bins?*: A bin represents a range of scores\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_histogram() +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n**Updating Bins:**\n\nWithin `geom_histogram()`, we can specify `bins = ` to specify the number of columns we want (for this example, lets say we want 10):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_histogram(bins = 10) +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nAlternatively, we can specify `binwidth = ` to specify the width of each bin (it is very helpful to be aware of the scale of your variable here!):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_histogram(binwidth = 0.1) +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n**Outline Columns with Color:**\n\nWithin `geom_histogram()`, we can specify `color = ` to set a colored outline of the columns:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_histogram(color = \"darkred\") +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n**Fill Columns with Color:**\n\nWithin `geom_histogram()`, we can specify `fill = ` to fill the columns with a color:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_histogram(fill = \"darkred\") +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n#### Density\n\nA visualization of the distribution of a numeric variable. \n\n**Basic:**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_density() +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Filled:**\n\nWe can fill our plot with colour by specifying `fill = ` within `geom_density()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_density(fill = \"darkred\") +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-18-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Line Type & Width:**\n\nWe can change the type and width of the line by specifying `linetype = ` and `linewidth = ` within `geom_density()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Sepal.Length)) +\n    geom_density(linetype = 6, linewidth = 3) +\n    labs(x = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-11' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-11', 'opt-start-11')\"> <span class=\"olab\">Bivariate Associations - Examples</span></span></div><div class=\"optional-body\" id = \"opt-body-11\" style=\"display: none;\">\n\n\n\nUnlike in our marginal plots where we specified our x-axis variable within `aes()`, to visualise bivariate associations, we need to specify what variables we want on both our x- and y-axis. \n\n::: {.panel-tabset}\n\n#### Scatterplot\n\nWe can use a scatterplot (since the variables are numeric and continuous) to visualise the association between the two numeric variables - these will be our x- and y-axis values. \n\nWe plot these values for each row of our dataset, and we should end up with a *cloud* of scattered points. \n\nHere we will want to comment on any key observations that we notice, including if we detect outliers or points that do not fit with the pattern in the rest of the data. Outliers are extreme observations that are not possible values of a variable or that do not seem to fit with the rest of the data. This could either be:\n\n+ *marginally* along one axis: points that have an unusual (too high or too low) x-coordinate or y-coordinate\n+ *jointly*: observations that do not fit with the rest of the point cloud \n\n**Basic:**\n\nWe need to specify `+ geom_point()` to get a scatterplot: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point() +\n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-20-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Fill Points with Color:**\n\nWithin `geom_point()`, we can specify `color = ` to fill the points with a color:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point(color = \"darkred\") +\n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-21-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Change Size and Opacity:**\n\nWe can change the size (using `size =`) and the opacity (using `alpha =`) of our geom elements on the plot. Let’s include this below:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point(size = 3, alpha = 0.5) +\n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Add a Line of Best Fit:**\n\nWe can superimpose (i.e., add) a line of best fit by including the argument `+ geom_smooth()`. Since we want to fit a straight line, we want to use `method = \"lm\"`. We can also specify whether we want to display confidence intervals around our line by specifying `se = TRUE / FALSE`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point() +\n    geom_smooth(method = \"lm\", se = FALSE) +\n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-23-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n#### Scatterplot of Matrices (SPLOM)\n\nUsing `pairs.panels()` is likely the most useful way to visualise the associations among numeric variables. It returns a scatterplot of matrices (SPLOM) returning you (1) the marginal distribution of each variable via a histogram, (2) the correlation between variables, and (3) bivariate scatterplots. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris |>\n    select(Sepal.Length, Petal.Length, Petal.Width) |>\n    pairs.panels(main = \"Iris SPLOM\")\n```\n\n::: {.cell-output-display}\n![Iris SPLOM](1_b2_reading_files/figure-html/fig-pairs-p-1.png){#fig-pairs-p fig-align='center' width=80%}\n:::\n:::\n\n\n#### Boxplot\n\nWe can use a boxplot to visualise the association between one numeric variable and one categorical variable - these will be our y- and x-axis values respectively.\n\n**Basic:**\n\nWe need to specify `+ geom_boxplot()` to get a boxplot: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Species, y = Sepal.Length)) +\n    geom_boxplot() +\n    labs(x = \"Species\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-25-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Change boxplot fill colours by group:**\n\nWithin `aes()`, we can specify `fill = ` to fill the boxes with a color:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Species, y = Sepal.Length, fill = Species)) +\n    geom_boxplot() +\n    labs(x = \"Species\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-26-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Change boxplot line colours by group:**\n\nWithin `aes()`, we can specify `color = ` to colour the lines with a color:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Species, y = Sepal.Length, color = Species)) +\n    geom_boxplot() +\n    labs(x = \"Species\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-27-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Adding jitter:**\n\nWe can add jittered points to a boxplot to better see the underlying distribution of the data (by adding a little random variation to each data point) via `geom_jitter()`: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Species, y = Sepal.Length, color = Species)) +\n    geom_boxplot() +\n    geom_jitter() + \n    labs(x = \"Species\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-28-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Change legend position:**\n\nWe can add the argument `+ theme(legend.position = )` to move (or even remove) the legend by specifying, for example, ` \"right\" `, ` \"left\" `, ` \"top\" `, ` \"bottom\" `, or  `\"none\" ` to remove. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# legend at bottom of plot\nggplot(data = iris, aes(x = Species, y = Sepal.Length, color = Species)) +\n    geom_boxplot() +\n    labs(x = \"Species\", y = \"Sepal Length (in cm)\") + \n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n#### Facets\n\nWhen we have two numeric variables, as well as categorical variables, we can use `facet_wrap()` / `facet_grid()` to help divide/arrange our plots. If we had two categorical variables, by simply stringing them together to further group our plots by specifying `facet_wrap( ~ cat_variable1 + cat_variable2)`\n\n**Basic:**\n\nWe need to specify `+ geom_point()` to get a scatterplot, and *either* `+ facet_wrap()` or  `+ facet_grid()` to separate by your categorical variable: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point() +\n    facet_wrap(~Species) + \n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-30-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Add a line of best fit:**\n\nWe can superimpose (i.e., add) a line of best fit by including the argument `+ geom_smooth()`. Since we want to fit a straight line, we want to use `method = \"lm\"`. We can also specify whether we want to display confidence intervals around our line by specifying `se = TRUE / FALSE`. Note that a line is fitted for every level of your categorical variable:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point() +\n    geom_smooth(method = \"lm\", se = FALSE) +\n        facet_wrap(~Species) + \n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-31-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n**Subplot layout:**\n\nYou can change the overall layout of the subplots by specifying `dir = ` within the `facet_wrap()` argument, where `“h”` will return a horizontal layout (this is the default) and `“v”` for vertical.\n\nYou can also change the layout of the subplot labels by specifying `strip.position = ` within the `facet_wrap()` argument, where labels can be arranged to display at the `“top”` (this is the default), `“bottom”`, `“left”` or `“right”`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) +\n    geom_point() +\n    facet_wrap(~Species, dir = \"v\", strip.position = \"right\") + \n    labs(x = \"Petal Length (in cm)\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-32-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-12' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-12', 'opt-start-12')\"> <span class=\"olab\">Multivariate Associations - Examples</span></span></div><div class=\"optional-body\" id = \"opt-body-12\" style=\"display: none;\">\n\n\n\nTo visualise multivariate associations, just like we do for bivariate associations, we need to specify what variables we want on both our x- and y-axis. We also need to take an extra step by specifying a third variable - z - that acts as a differentiating factor across our data. This 'z' can be mapped to an aesthetic attribute such as color, shape, or size, allowing us to explore more dynamic patterns and ssociations in our data. \n\nIf you *really* wanted to, you could create a plot showing the associations among three variables at once. These are likely more useful when you have an interaction model. However, we wouldn't really recommend doing this - they can be very difficult to interpret correctly, and given their interactive nature, definitely NOT something that you'd want to include in a stats report. But, for demonstration purposes only, we could create one using the **plotly** package.\n\n**3D Scatterplot**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(plotly)\n\nplot_ly(data = iris, \n        x = ~Petal.Length, y = ~Sepal.Length, z = ~Petal.Width, \n        type = 'scatter3d', \n        mode = 'markers+lines',\n        scene = list(\n            xaxis = list(title = \"Petal Length\"),\n            yaxis = list(title = \"Sepal Length\"),\n            zaxis = list(title = \"Petal Width\")\n            )\n        )\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"plotly html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-2dcdb2d09fea65077066\" style=\"width:80%;height:480px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-2dcdb2d09fea65077066\">{\"x\":{\"visdat\":{\"2a8c95337e3\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"2a8c95337e3\",\"attrs\":{\"2a8c95337e3\":{\"x\":{},\"y\":{},\"z\":{},\"mode\":\"markers+lines\",\"scene\":{\"xaxis\":{\"title\":\"Petal Length\"},\"yaxis\":{\"title\":\"Sepal Length\"},\"zaxis\":{\"title\":\"Petal Width\"}},\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"type\":\"scatter3d\"}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"scene\":{\"xaxis\":{\"title\":\"Petal.Length\"},\"yaxis\":{\"title\":\"Sepal.Length\"},\"zaxis\":{\"title\":\"Petal.Width\"}},\"hovermode\":\"closest\",\"showlegend\":false},\"source\":\"A\",\"config\":{\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"data\":[{\"x\":[1.3999999999999999,1.3999999999999999,1.3,1.5,1.3999999999999999,1.7,1.3999999999999999,1.5,1.3999999999999999,1.5,1.5,1.6000000000000001,1.3999999999999999,1.1000000000000001,1.2,1.5,1.3,1.3999999999999999,1.7,1.5,1.7,1.5,1,1.7,1.8999999999999999,1.6000000000000001,1.6000000000000001,1.5,1.3999999999999999,1.6000000000000001,1.6000000000000001,1.5,1.5,1.3999999999999999,1.5,1.2,1.3,1.3999999999999999,1.3,1.5,1.3,1.3,1.3,1.6000000000000001,1.8999999999999999,1.3999999999999999,1.6000000000000001,1.3999999999999999,1.5,1.3999999999999999,4.7000000000000002,4.5,4.9000000000000004,4,4.5999999999999996,4.5,4.7000000000000002,3.2999999999999998,4.5999999999999996,3.8999999999999999,3.5,4.2000000000000002,4,4.7000000000000002,3.6000000000000001,4.4000000000000004,4.5,4.0999999999999996,4.5,3.8999999999999999,4.7999999999999998,4,4.9000000000000004,4.7000000000000002,4.2999999999999998,4.4000000000000004,4.7999999999999998,5,4.5,3.5,3.7999999999999998,3.7000000000000002,3.8999999999999999,5.0999999999999996,4.5,4.5,4.7000000000000002,4.4000000000000004,4.0999999999999996,4,4.4000000000000004,4.5999999999999996,4,3.2999999999999998,4.2000000000000002,4.2000000000000002,4.2000000000000002,4.2999999999999998,3,4.0999999999999996,6,5.0999999999999996,5.9000000000000004,5.5999999999999996,5.7999999999999998,6.5999999999999996,4.5,6.2999999999999998,5.7999999999999998,6.0999999999999996,5.0999999999999996,5.2999999999999998,5.5,5,5.0999999999999996,5.2999999999999998,5.5,6.7000000000000002,6.9000000000000004,5,5.7000000000000002,4.9000000000000004,6.7000000000000002,4.9000000000000004,5.7000000000000002,6,4.7999999999999998,4.9000000000000004,5.5999999999999996,5.7999999999999998,6.0999999999999996,6.4000000000000004,5.5999999999999996,5.0999999999999996,5.5999999999999996,6.0999999999999996,5.5999999999999996,5.5,4.7999999999999998,5.4000000000000004,5.5999999999999996,5.0999999999999996,5.0999999999999996,5.9000000000000004,5.7000000000000002,5.2000000000000002,5,5.2000000000000002,5.4000000000000004,5.0999999999999996],\"y\":[5.0999999999999996,4.9000000000000004,4.7000000000000002,4.5999999999999996,5,5.4000000000000004,4.5999999999999996,5,4.4000000000000004,4.9000000000000004,5.4000000000000004,4.7999999999999998,4.7999999999999998,4.2999999999999998,5.7999999999999998,5.7000000000000002,5.4000000000000004,5.0999999999999996,5.7000000000000002,5.0999999999999996,5.4000000000000004,5.0999999999999996,4.5999999999999996,5.0999999999999996,4.7999999999999998,5,5,5.2000000000000002,5.2000000000000002,4.7000000000000002,4.7999999999999998,5.4000000000000004,5.2000000000000002,5.5,4.9000000000000004,5,5.5,4.9000000000000004,4.4000000000000004,5.0999999999999996,5,4.5,4.4000000000000004,5,5.0999999999999996,4.7999999999999998,5.0999999999999996,4.5999999999999996,5.2999999999999998,5,7,6.4000000000000004,6.9000000000000004,5.5,6.5,5.7000000000000002,6.2999999999999998,4.9000000000000004,6.5999999999999996,5.2000000000000002,5,5.9000000000000004,6,6.0999999999999996,5.5999999999999996,6.7000000000000002,5.5999999999999996,5.7999999999999998,6.2000000000000002,5.5999999999999996,5.9000000000000004,6.0999999999999996,6.2999999999999998,6.0999999999999996,6.4000000000000004,6.5999999999999996,6.7999999999999998,6.7000000000000002,6,5.7000000000000002,5.5,5.5,5.7999999999999998,6,5.4000000000000004,6,6.7000000000000002,6.2999999999999998,5.5999999999999996,5.5,5.5,6.0999999999999996,5.7999999999999998,5,5.5999999999999996,5.7000000000000002,5.7000000000000002,6.2000000000000002,5.0999999999999996,5.7000000000000002,6.2999999999999998,5.7999999999999998,7.0999999999999996,6.2999999999999998,6.5,7.5999999999999996,4.9000000000000004,7.2999999999999998,6.7000000000000002,7.2000000000000002,6.5,6.4000000000000004,6.7999999999999998,5.7000000000000002,5.7999999999999998,6.4000000000000004,6.5,7.7000000000000002,7.7000000000000002,6,6.9000000000000004,5.5999999999999996,7.7000000000000002,6.2999999999999998,6.7000000000000002,7.2000000000000002,6.2000000000000002,6.0999999999999996,6.4000000000000004,7.2000000000000002,7.4000000000000004,7.9000000000000004,6.4000000000000004,6.2999999999999998,6.0999999999999996,7.7000000000000002,6.2999999999999998,6.4000000000000004,6,6.9000000000000004,6.7000000000000002,6.9000000000000004,5.7999999999999998,6.7999999999999998,6.7000000000000002,6.7000000000000002,6.2999999999999998,6.5,6.2000000000000002,5.9000000000000004],\"z\":[0.20000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.40000000000000002,0.29999999999999999,0.20000000000000001,0.20000000000000001,0.10000000000000001,0.20000000000000001,0.20000000000000001,0.10000000000000001,0.10000000000000001,0.20000000000000001,0.40000000000000002,0.40000000000000002,0.29999999999999999,0.29999999999999999,0.29999999999999999,0.20000000000000001,0.40000000000000002,0.20000000000000001,0.5,0.20000000000000001,0.20000000000000001,0.40000000000000002,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.40000000000000002,0.10000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.10000000000000001,0.20000000000000001,0.20000000000000001,0.29999999999999999,0.29999999999999999,0.20000000000000001,0.59999999999999998,0.40000000000000002,0.29999999999999999,0.20000000000000001,0.20000000000000001,0.20000000000000001,0.20000000000000001,1.3999999999999999,1.5,1.5,1.3,1.5,1.3,1.6000000000000001,1,1.3,1.3999999999999999,1,1.5,1,1.3999999999999999,1.3,1.3999999999999999,1.5,1,1.5,1.1000000000000001,1.8,1.3,1.5,1.2,1.3,1.3999999999999999,1.3999999999999999,1.7,1.5,1,1.1000000000000001,1,1.2,1.6000000000000001,1.5,1.6000000000000001,1.5,1.3,1.3,1.3,1.2,1.3999999999999999,1.2,1,1.3,1.2,1.3,1.3,1.1000000000000001,1.3,2.5,1.8999999999999999,2.1000000000000001,1.8,2.2000000000000002,2.1000000000000001,1.7,1.8,1.8,2.5,2,1.8999999999999999,2.1000000000000001,2,2.3999999999999999,2.2999999999999998,1.8,2.2000000000000002,2.2999999999999998,1.5,2.2999999999999998,2,2,1.8,2.1000000000000001,1.8,1.8,1.8,2.1000000000000001,1.6000000000000001,1.8999999999999999,2,2.2000000000000002,1.5,1.3999999999999999,2.2999999999999998,2.3999999999999999,1.8,1.8,2.1000000000000001,2.3999999999999999,2.2999999999999998,1.8999999999999999,2.2999999999999998,2.5,2.2999999999999998,1.8999999999999999,2,2.2999999999999998,1.8],\"mode\":\"markers+lines\",\"scene\":{\"xaxis\":{\"title\":\"Petal Length\"},\"yaxis\":{\"title\":\"Sepal Length\"},\"zaxis\":{\"title\":\"Petal Width\"}},\"type\":\"scatter3d\",\"marker\":{\"color\":\"rgba(31,119,180,1)\",\"line\":{\"color\":\"rgba(31,119,180,1)\"}},\"error_y\":{\"color\":\"rgba(31,119,180,1)\"},\"error_x\":{\"color\":\"rgba(31,119,180,1)\"},\"line\":{\"color\":\"rgba(31,119,180,1)\"},\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.20000000000000001,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n**Heatmap of Correlations**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_ly(z = ~cor(iris[, c(1, 3:4)]), type = \"heatmap\")\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"plotly html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-6b356b3775a4c68d7c0f\" style=\"width:80%;height:480px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-6b356b3775a4c68d7c0f\">{\"x\":{\"visdat\":{\"2a8c141d2eb1\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"2a8c141d2eb1\",\"attrs\":{\"2a8c141d2eb1\":{\"z\":{},\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"type\":\"heatmap\"}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"scene\":{\"zaxis\":{\"title\":\"cor(iris[, c(1, 3:4)])\"}},\"xaxis\":{\"domain\":[0,1],\"automargin\":true},\"yaxis\":{\"domain\":[0,1],\"automargin\":true},\"hovermode\":\"closest\",\"showlegend\":false,\"legend\":{\"yanchor\":\"top\",\"y\":0.5}},\"source\":\"A\",\"config\":{\"modeBarButtonsToAdd\":[\"hoverclosest\",\"hovercompare\"],\"showSendToCloud\":false},\"data\":[{\"colorbar\":{\"title\":\"cor(iris[, c(1, 3:4)])\",\"ticklen\":2,\"len\":0.5,\"lenmode\":\"fraction\",\"y\":1,\"yanchor\":\"top\"},\"colorscale\":[[\"0\",\"rgba(68,1,84,1)\"],[\"0.0416666666666667\",\"rgba(70,19,97,1)\"],[\"0.0833333333333334\",\"rgba(72,32,111,1)\"],[\"0.125\",\"rgba(71,45,122,1)\"],[\"0.166666666666667\",\"rgba(68,58,128,1)\"],[\"0.208333333333333\",\"rgba(64,70,135,1)\"],[\"0.25\",\"rgba(60,82,138,1)\"],[\"0.291666666666667\",\"rgba(56,93,140,1)\"],[\"0.333333333333334\",\"rgba(49,104,142,1)\"],[\"0.375\",\"rgba(46,114,142,1)\"],[\"0.416666666666667\",\"rgba(42,123,142,1)\"],[\"0.458333333333334\",\"rgba(38,133,141,1)\"],[\"0.5\",\"rgba(37,144,140,1)\"],[\"0.541666666666666\",\"rgba(33,154,138,1)\"],[\"0.583333333333333\",\"rgba(39,164,133,1)\"],[\"0.625\",\"rgba(47,174,127,1)\"],[\"0.666666666666667\",\"rgba(53,183,121,1)\"],[\"0.708333333333333\",\"rgba(79,191,110,1)\"],[\"0.75\",\"rgba(98,199,98,1)\"],[\"0.791666666666667\",\"rgba(119,207,85,1)\"],[\"0.833333333333333\",\"rgba(147,214,70,1)\"],[\"0.875\",\"rgba(172,220,52,1)\"],[\"0.916666666666667\",\"rgba(199,225,42,1)\"],[\"0.958333333333333\",\"rgba(226,228,40,1)\"],[\"1\",\"rgba(253,231,37,1)\"]],\"showscale\":true,\"z\":[[1,0.8717537758865832,0.81794112627157578],[0.8717537758865832,1,0.96286543140279601],[0.81794112627157578,0.96286543140279601,1]],\"type\":\"heatmap\",\"xaxis\":\"x\",\"yaxis\":\"y\",\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.20000000000000001,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Functions and Mathematical Models\n\nBasic functions and mathematical models are foundational tools used to describe and predict associations between variables.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-13' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-13', 'opt-start-13')\"> <span class=\"olab\">Identification & Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-13\" style=\"display: none;\">\n\n\n\nConsider the function $y = 2 + 5 \\ x$. From this, we can do the following:\n\n- Identify the Dependent Variable (DV)\n- Identify the Independent Variable (IV)\n- Describe in words what the function does, and compute the output for the following input:\n\n$$\nx = \\begin{bmatrix}\n2 \\\\\n6\n\\end{bmatrix}\n$$\n\nThe function says that the $y$ value is obtained as a transformation of the $x$ value.\n\n- The dependent variable is $y$\n- The independent variable is $x$\n- The $y$ value is calculated as two plus five times $x$\n\n<br />\nExample (1): If $x$ equals 2, the corresponding value of $y$ will be $2 + (5 \\cdot 2) = 12$.\n<br />\nExample (2): If $x$ equals 6, the corresponding value of $y$ will be $2 + (5 \\cdot 6) = 32$.\n\n$$\ny = \\begin{bmatrix}\n2 + 5 \\cdot 2 \\\\\n2 + 5 \\cdot 6\n\\end{bmatrix}\n= \\begin{bmatrix}\n12 \\\\\n32\n\\end{bmatrix}\n$$\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Deterministic Models\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-14' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-14', 'opt-start-14')\"> <span class=\"olab\">Description & Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-14\" style=\"display: none;\">\n\n\n\nWe come across functions *a lot* in daily life, and probably don't think much about it. In a slightly more mathematical setting, we can write down in words and in symbols the function describing the association between the side of a square and its perimeter (e.g., to capture *how* the perimeter *varies* as a *function* of its side). In this case, the perimeter is the dependent variable, and the side is the independent variable.\n\nThis is what we would refer to as a *deterministic model*, as it is a model of an *exact relationship* - there can be no deviation.\n\n**Model Specification**\n\n::: {.panel-tabset}\n\n## In words\n\nThe perimeter of a square is four times the length of its side.\n\n\n## In symbols\n\nThe relationship between side and perimeter of squares is given by:\n\n$$\n\\text{Perimeter} = 4 \\cdot \\text{Side}\n$$\n\nIf you denote $y$ as the dependent variable _Perimeter_, and $x$ as the independent variable _Side_ we can rewrite as: \n\n$$\ny = 4 \\cdot x\n$$\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-15' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-15', 'opt-start-15')\"> <span class=\"olab\">Visualisation</span></span></div><div class=\"optional-body\" id = \"opt-body-15\" style=\"display: none;\">\n\n\n\nLet's create a dataset called `squares`, containing the perimeter of four squares having sides of length $0, 2, 5, 9$ metres, and then plot the `squares` data as points on a scatterplot. \n\nFirst, let's make our squares data. Here we will use two important functions - `tibble()` and `c()`. The `tibble()` function allows us to construct a data frame. To store a sequence of numbers into R, we can **c**ombine the values using `c()`. A sequence of elements all of the same type is called a *vector*.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#create data frame named squares\nsquares <- tibble(\n  side = c(0, 2, 5, 9), \n  perimeter = 4 * side\n)\n\n#check that our values are contained within squares\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n   side perimeter\n  <dbl>     <dbl>\n1     0         0\n2     2         8\n3     5        20\n4     9        36\n```\n:::\n:::\n\n\nNow we know how `ggplot()` works, we can start to build our plot. First we specify our data (we want to use the *squares* data frame), and then our aesthetics. Since the perimeter varies as a function of side, we want side on the $x$-axis, and perimeter on the $y$-axis. We want to create a scatterplot, so we need to specify our `geom_...` argument as `geom_point()`. Lastly, we will provide clearer axis labels, and include the units of measurement. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = squares, aes(x = side, y = perimeter)) +\n  geom_point() +  \n  labs(x = 'Side (m)', y = 'Perimeter (m)',  title = 'Perimeter = 4*Side')  \n```\n\n::: {.cell-output-display}\n![Perimeter = 4*Side](1_b2_reading_files/figure-html/fig-squares1-1.png){#fig-squares1 fig-align='center' width=80%}\n:::\n:::\n\n\nWe could also visualise the functional relationship by connecting the individual points with a line. To do so, we need to add a new argument - `geom_line()`. If you would like to change the colour of the line from the default, you can specify `geom_line(colour = \"insert colour name\")`. \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = squares, aes(x = side, y = perimeter)) +\n  geom_point() +\n  geom_line(colour = \"darkred\") + \n  labs(x = 'Side (m)', y = 'Perimeter (m)',  title = 'Perimeter = 4*Side')  \n```\n\n::: {.cell-output-display}\n![Perimeter = 4*Side](1_b2_reading_files/figure-html/fig-squares2-1.png){#fig-squares2 fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-16' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-16', 'opt-start-16')\"> <span class=\"olab\">Predicted Values</span></span></div><div class=\"optional-body\" id = \"opt-body-16\" style=\"display: none;\">\n\n\n\nSometimes we can directly read a predicted value from the graph of the functional relationship.\n\nConsider the plot created above. For example, first we need to check where $x$ = 2.5. Then, we draw a vertical dashed line until it meets the blue line. The $y$ value corresponding to $x$ = 2.5 can be read off the $y$-axis. In our case, we would say a side of 2.5m corresponds to a perimeter of 10m. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = squares, aes(x = side, y = perimeter)) +\n  geom_point() +\n  geom_line(colour = \"blue\") + \n  geom_vline(xintercept = 2.5, colour = \"darkred\", lty = \"dashed\", lwd = 1) + \n  labs(x = 'Side (m)', y = 'Perimeter (m)',  title = 'Perimeter = 4 * Side')  \n```\n\n::: {.cell-output-display}\n![Perimeter = 4*Side](1_b2_reading_files/figure-html/fig-squares3-1.png){#fig-squares3 fig-align='center' width=80%}\n:::\n:::\n\n\nHowever, in this case it is not that easy to read it from @fig-squares3 (especially without the superimposed dashed red line)... This leads us to the algebraic approach:\n\nWe can substitute the $x$ value in the formula and calculate the corresponding $y$ value where we would conclude that the predicted perimeter of squared paintings having a 2.5m side is 10m:\n\n$$\ny = 4 \\cdot x  \\\\    \n$$\n\n$$\ny = 4 \\cdot 2.5 \\\\  \n$$\n\n$$\ny = 10  \\\\\n$$\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Statistical Models\n\nStatistical models are used to understand the associations among variables.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-17' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-17', 'opt-start-17')\"> <span class=\"olab\">Specifying Hypotheses</span></span></div><div class=\"optional-body\" id = \"opt-body-17\" style=\"display: none;\">\n\n\n\nWe need to specify our hypotheses when testing a model as this not only defines what we are testing, but also sets the direction for statistical inference. By specifying a null hypothesis (typically stating no effect or no association) and an alternative hypothesis (indicating the presence of an association), we create a structured approach for determining the statistical significance of model parameters. Without specifying hypotheses, the interpretation of results would lack focus, making it difficult to assess the validity and relevance of the model's findings.\n\nIn regression analysis, hypothesis testing for beta coefficients is used to assess whether (each) predictor variable significantly contributes to the model. \n\nThe way we specify hypotheses is similar across simple and multiple regression models.\n\nFor each regression coefficient $\\beta_j$ (for predictor $X_j$):\n\n+ Null hypothesis ($H_0$) = $\\beta_j = 0$: The predictor variable ($X_j$) is not associated with the DV  \n+ Alternative hypothesis ($H_1$) = $\\beta_j \\neq 0$: The predictor variable ($X_j$) is associated with the DV  \n  \n  \nBased on the $p$-value or comparison of the $t$-statistic with the critical value, you can conclude whether the predictor variable is significant or not (see the simple & multiple regression Models - extracting information > model coefficients flashcard below):\n\n+ Reject $H_0$ if $|t_j|$ > critical value or $p$-value $< \\alpha$ \n+ Fail to reject $H_0$ if $|t_j|$ $\\leq$ critical value or $p$-value $\\geq \\alpha$ \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n## Numeric Outcomes & Numeric Predictors\n\n### Simple Linear Regression Models\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-18' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-18', 'opt-start-18')\"> <span class=\"olab\">Description & Model Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-18\" style=\"display: none;\">\n\n\n\nThe association between two variables (e.g., recall accuracy and age) will show deviations from the 'average pattern'. Hence, we need to create a model that allows for deviations from the linear relationship - we need a _statistical model_.\n\nA statistical model includes *both* a deterministic function and a random error term. We typically refer to the outcome (‘dependent’) variable with the letter $y$ and to our predictor (‘explanatory’/‘independent’) variables with the letter $x$. A simple (i.e., one x variable only) linear regression model thus takes the following form (where the terms $\\beta_0$ and $\\beta_1$ are numbers specifying where the line going through the data meets the y-axis (i.e., the intercept - where $x$ = 0; $\\beta_0$) and its slope (direction and gradient of line; $\\beta_1$):\n\n**Model Specification**\n\n$$\ny_i = \\beta_0 + \\beta_1 \\cdot x_i + \\epsilon_i    \n$$\n\n**Model Specification: Annotated**\n\n$$\ny_i = \\underbrace{\\beta_0 + \\beta_1 \\cdot x_i}_{\\text{function of }x} + \\underbrace{\\epsilon_i}_{\\text{random error}}  \n\\\\\n$$\n\n$$\n\\quad \\text{where} \\quad \\epsilon_i \\sim N(0, \\sigma) \\text{ independently}\n$$\n\n\n**Model Specification: Explained**\n\nLet's break down what $y_i = \\beta_0 + \\beta_1 \\cdot x_i + \\epsilon_i \\quad \\text{where} \\quad \\epsilon_i \\sim N(0, \\sigma) \\text{ independently}$ actually means by considering the statement in smaller parts:\n\n+ *$y_i = \\beta_0 + \\beta_1 \\cdot x_i$*  \n  \n    + $y_i$ is our measured outcome variable (our DV)  \n    + $x_i$ is our measured predictor variable (our IV)  \n    + $\\beta_0$ is the model intercept  \n    + $\\beta_1$ is the model slope  \n\n+ *$\\epsilon \\sim N(0, \\sigma) \\text{ independently}$*   \n  \n    + $\\epsilon$ is the residual error   \n    + $\\sim$ means 'distributed according to'    \n    + $N(0, \\sigma) \\text{ independently}$ means 'normal distribution with a mean of 0 and a variance of $\\sigma$'   \n    + Together, we can say that the errors around the line have a mean of zero and constant spread as x varies    \n\n\n:::blue\n**In R**\n\nThere are basically two pieces of information that we need to pass to the `lm()` function:\n\n1. The formula: The regression formula should be specified in the form `y ~ x` where $y$ is the dependent variable (DV) and $x$ the independent variable (IV).\n2. The data: Specify which dataframe contains the variables specified in the formula.\n\nIn `R`, the syntax of the `lm()` function can be specified as follows (where DV = dependent variable, IV = independent variable, and data_name = the name of your dataset):\n\n::: {.panel-tabset}\n\n## Option A\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(DV ~ IV, data = data_name) \n```\n:::\n\n\n## Option B\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(data_name$DV ~ data_name$IV)\n```\n:::\n\n\n:::\n\nyou can also specify as: \n\n::: {.panel-tabset}\n\n## Option A\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(DV ~ 1 + IV, data = data_name) \n```\n:::\n\n\n## Option B\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(data_name$DV ~ 1 + data_name$IV)\n```\n:::\n\n\n:::\n\n::: {.callout-important icon=false collapse=true}\n## Why is there a 1 in the two bottom options? \n\nWhen we specify the linear model in `R`, we include after the tilde sign ($\\sim$), the variables that appear to the right of the $\\hat \\beta$s. The intercept, or $\\beta_0$, is a constant. That is, we could write it as multiplied by 1.\n\nIncluding the 1 explicitly is not necessary because it is included by default (you can check this by comparing the outputs of A & B above with and without the 1 included - the estimates are the same!). After a while, you will find you just want to drop the 1 when calling `lm()` because you know that it’s going to be there, but in these early weeks we tried to keep it explicit to make it clear that you want the intercept to be estimated. \n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n#### Example\n\n> **Research Question** \n>\n> Is there an association between recall accuracy and age?  \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-19' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-19', 'opt-start-19')\"> <span class=\"olab\">Overview</span></span></div><div class=\"optional-body\" id = \"opt-body-19\" style=\"display: none;\">\n\n\n\nImagine that you were tasked to investigate whether there was an association between recall accuracy and age. You have been provided with data from twenty participants who studied passages of text (c500 words long), and were tested a week later. The testing phase presented participants with 100 statements about the text. They had to answer whether each statement was true or false, as well as rate their confidence in each answer (on a sliding scale from 0 to 100). The dataset contains, for each participant, the percentage of items correctly answered, their age (in years), and their average confidence rating. \n\nThe data are available at [https://uoepsy.github.io/data/recalldata.csv](https://uoepsy.github.io/data/recalldata.csv)\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-20' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-20', 'opt-start-20')\"> <span class=\"olab\">Visualise Data</span></span></div><div class=\"optional-body\" id = \"opt-body-20\" style=\"display: none;\">\n\n \n\nThere are lots of different ways in which we can visualise our data (as per the [Visual Exploration flashcards](https://uoepsy.github.io/dapr2/2526/labs/1_b1_reading.html#visual-exploration)). \n\nFor the marginal distributions we will use density and boxplots, and for the bivariate associations a scatterplot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#save plots to individual objects in order to arrange \n\nplt1 <- ggplot(data = recalldata, aes(x = recall_accuracy)) + \n    geom_density() +\n    xlim(0, 100) + #specify x-axis to range from 0-100\n    geom_boxplot(width = 1/100) + \n    labs(x = \"Recall Accuracy (%)\", title = \"Distribtion of \\nRecall Accuracy\")\n\nplt2 <- ggplot(data = recalldata, aes(x = age)) + \n    geom_density() +\n    xlim(0, 100) + #specify x-axis to range from 0-100\n    geom_boxplot(width = 1/100) + \n    labs(x = \"Age (in years)\", title = \"Distribtion of \\nAge\")\n\nplt3 <- ggplot(data = recalldata, aes(x = age, y = recall_accuracy)) + \n    geom_point() + \n    labs(x = \"Age (in years)\", y = \"Recall Accuracy (%)\", title = \"Association between Recall Accuracy and Age\")\n\n\n#load patchwork package to arrange plots\nlibrary(patchwork)\n\n#arrange plots where there are two plots in to panel (plt1 + plt2), one on bottom (plt3)\n(plt1 + plt2) / plt3\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-43-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n+ The marginal distribution of recall accuracy was unimodal with a negative skew with a mean of approximately 69.25. There was high variation in recall accuracy (SD = 14.53)   \n+ The marginal distribution of age was unimodal with a mean of approximately 48.8, where age ranged from 22 to 86  \n+ There appeared to be a weak negative association between recall accuracy and age, where older age was associated with lower recall accuracy  \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-21' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-21', 'opt-start-21')\"> <span class=\"olab\">Model & Hypothesis Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-21\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n## Model Specification \n\n$$\n\\text{Recall Accuracy}_i = \\beta_0 + \\beta_1 \\cdot \\text{Age}_i + \\epsilon_i    \n$$\n\n## Hypothesis Specification\n\n$H_0: \\beta_1 = 0$  \n   \nThere is no association between recall accuracy and age. \n\n$H_1: \\beta_1 \\neq 0$  \n  \nThere is an association between recall accuracy and age.\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-22' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-22', 'opt-start-22')\"> <span class=\"olab\">Model Building</span></span></div><div class=\"optional-body\" id = \"opt-body-22\" style=\"display: none;\">\n\n \n\nTo fit the model in `R` we use the `lm()` function. The simple linear model is assigned/stored in an object called `recall_simp`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecall_simp <- lm(recall_accuracy ~ age, data = recalldata)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecall_simp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = recall_accuracy ~ age, data = recalldata)\n\nCoefficients:\n(Intercept)          age  \n    84.0153      -0.3026  \n```\n:::\n:::\n\n\nWhen we call the name of the fitted model, `recall_simp`, you can see the estimated regression coefficients $\\hat \\beta_0$ and $\\hat \\beta_1$. The line of best-fit is thus given by:^[Yes, the error term is gone. This is because the line of best-fit gives you the prediction of the average recall accuracy for a given age, and not the individual recall accuracy of an individual person, which will almost surely be different from the prediction of the line.]\n\n$$\n\\widehat{\\text{Recall Accuracy}} = 84.02 - 0.31 \\cdot \\text{Age}\n$$\n\n<br>\n\nAlternatively to get these same estimates, we could have used the `summary()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(recall_simp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = recall_accuracy ~ age, data = recalldata)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-25.164  -7.761  -2.656   9.593  26.180 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  84.0153    11.4453   7.341 8.16e-07 ***\nage          -0.3026     0.2253  -1.343    0.196    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 14.23 on 18 degrees of freedom\nMultiple R-squared:  0.09108,\tAdjusted R-squared:  0.04058 \nF-statistic: 1.804 on 1 and 18 DF,  p-value: 0.196\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-23' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-23', 'opt-start-23')\"> <span class=\"olab\">Results Interpretation</span></span></div><div class=\"optional-body\" id = \"opt-body-23\" style=\"display: none;\">\n\n \n\n::: {.panel-tabset}\n\n## `(Intercept)`   \n\n$\\beta_0$ = `(Intercept)` = 84.02  \n  \n+ The intercept, or predicted recall accuracy when age was 0.  \n    - An individual aged 0 years was expected to have a recall accuracy of $84.02$.  \n    \n\n*Note:* the intercept isn’t very useful here at all. It estimates the accuracy for a newborn (who wouldn’t be able to complete the task!).\n    \n## `age`   \n\n$\\beta_1$ = `age` = -0.3   \n  \n+ The estimated difference in recall accuracy for each additional year in age.  \n    - Every 1 additional year in age was associated with a non-significant $-0.3$ percentage point decrease in recall accuracy $(p = .196)$. This suggested that age was not significantly associated with recall accuracy.\n    \n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-24' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-24', 'opt-start-24')\"> <span class=\"olab\">Model Visualisation</span></span></div><div class=\"optional-body\" id = \"opt-body-24\" style=\"display: none;\">\n\n \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(recalldata, aes(x = age, y = recall_accuracy)) + \n    geom_point(size = 3, alpha = 0.5) +\n    geom_smooth(method = lm, se = FALSE) + \n    ylim(0,100) +\n    labs(x = \"Age (in years)\", y = \"Recall Accuracy (%)\", title = \"Association between Recall Accuracy and Age\")\n```\n\n::: {.cell-output-display}\n![Association between Recall Accuracy and Age](1_b2_reading_files/figure-html/fig-recallage-fitted-model-1.png){#fig-recallage-fitted-model fig-align='center' width=80%}\n:::\n:::\n\n\nThe line that best fits the association between recall accuracy and age (see @fig-recallage-fitted-model) is only able to predict the **average** accuracy for a given value of age.\n\nThis is because there will be a distribution of recall accuracy at each value of age. The line will fit the trend/pattern in the values, but there will be individual-to-individual variability that we must accept around that average pattern.\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n### Multiple Linear Regression Models\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-25' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-25', 'opt-start-25')\"> <span class=\"olab\">Description & Model Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-25\" style=\"display: none;\">\n\n\n\nMultiple linear regression involves looking at one continuous outcome (i.e., DV), with two or more independent variables (i.e., IVs). \n\nA multiple linear regression model takes the following form:\n\n$$\ny_i = \\beta_0 + \\beta_1 \\cdot x_{1_i} + \\beta_2 \\cdot x_{2_i} + .... + \\beta_j \\cdot x_{j_i} + \\epsilon_i\n$$\n\n$$\n\\quad \\text{where} \\quad \\epsilon_i \\sim N(0, \\sigma) \\text{ independently}\n$$\n\n:::blue\n\nIn **R**:\n\nMultiple and simple linear regression follow the same structure within the `lm()` function - the logic scales up to however many predictor variables we want to include in our model. You simply add (using the `+` sign) more independent variables. For example, if we wanted to build a multiple linear regression that included three independent variables, we could fit one of the following via the `lm()` function:\n\n::: {.panel-tabset}\n\n## Option A\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(DV ~ IV1 + IV2 + IV3, data = data_name)\n```\n:::\n\n\n## Option B\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel_name <- lm(data_name$DV ~ data_name$IV1 + data_name$IV2 + data_name$IV3)\n```\n:::\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-26' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-26', 'opt-start-26')\"> <span class=\"olab\">Interpretation of Coefficients</span></span></div><div class=\"optional-body\" id = \"opt-body-26\" style=\"display: none;\">\n\n\n\nYou'll hear a lot of different ways that people explain multiple regression coefficients.  \n\nFor the model $y = \\beta_0 + \\beta_1 \\cdot x_1 + \\beta_2 \\cdot x_2 + \\epsilon$, the estimate $\\hat \\beta_1$ will often be reported as:  \n  \n\"the increase in $y$ for a one unit increase in $x_1$ when...\"\n\n- \"holding the effect of $x_2$ constant.\"\n- \"controlling for differences in $x_2$.\"\n- \"partialling out the effects of $x_2$.\"\n- \"holding $x_2$ equal.\"\n- \"accounting for effects of $x_2$.\" \n\nFor models with 3+ predictors, just like building the model in `R`, the logic of the above simply extends. \n\nFor example “the increase in [outcome] for a one unit increase in [predictor] when...”\n\n- “holding [other predictors] constant.”  \n- “accounting for [other predictors].”  \n- “controlling for differences in [other predictors].”  \n- “partialling out the effects of [other predictors].”  \n- “holding [other predictors] equal.”  \n- “accounting for effects of [other predictors].”  \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n#### Example\n\n> **Research Question** \n>\n> Is recall accuracy associated with recall confidence and age?  \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-27' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-27', 'opt-start-27')\"> <span class=\"olab\">Overview</span></span></div><div class=\"optional-body\" id = \"opt-body-27\" style=\"display: none;\">\n\n\n\nImagine that you were tasked to investigate whether recall accuracy was associated with recall confidence and age. You have been provided with data from twenty participants who studied passages of text (c500 words long), and were tested a week later. The testing phase presented participants with 100 statements about the text. They had to answer whether each statement was true or false, as well as rate their confidence in each answer (on a sliding scale from 0 to 100). The dataset contains, for each participant, the percentage of items correctly answered, their age (in years), and their average confidence rating. \n\nThe data are available at [https://uoepsy.github.io/data/recalldata.csv](https://uoepsy.github.io/data/recalldata.csv)\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-28' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-28', 'opt-start-28')\"> <span class=\"olab\">Visualise Data</span></span></div><div class=\"optional-body\" id = \"opt-body-28\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecalldata |>\n    select(recall_accuracy, recall_confidence, age) |>\n    pairs.panels(main = \"Recall SPLOM\")\n```\n\n::: {.cell-output-display}\n![Recall SPLOM](1_b2_reading_files/figure-html/fig-pairsp2-1.png){#fig-pairsp2 fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-29' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-29', 'opt-start-29')\"> <span class=\"olab\">Model & Hypothesis Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-29\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n## Model Specification \n\n$$\n\\text{Recall Accuracy}_i = \\beta_0 + \\beta_1 \\cdot \\text{Recall Confidence}_i + \\beta_2 \\cdot \\text{Age}_i + \\epsilon_i \\\\\n$$\n\n## Hypothesis Specification\n\n$H_0:$ All $\\beta_j = 0$ (for $j = 1, 2$)\n\nThere is no association between recall accuracy and recall confidence and/or age. \n\n$H_1:$ At least one $\\beta_j \\neq  0$ (for $j = 1, 2$)\n\nThere is an association between recall accuracy and recall confidence and/or age. \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-30' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-30', 'opt-start-30')\"> <span class=\"olab\">Model Building</span></span></div><div class=\"optional-body\" id = \"opt-body-30\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrecall_multi <- lm(recall_accuracy ~ recall_confidence + age, data = recalldata)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(recall_multi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = recall_accuracy ~ recall_confidence + age, data = recalldata)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-12.1935  -5.1751  -0.5528   2.5934  18.6814 \n\nCoefficients:\n                  Estimate Std. Error t value Pr(>|t|)    \n(Intercept)        36.1596    12.8413   2.816 0.011900 *  \nrecall_confidence   0.8957     0.1912   4.685 0.000213 ***\nage                -0.3392     0.1534  -2.212 0.040985 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 9.674 on 17 degrees of freedom\nMultiple R-squared:  0.6033,\tAdjusted R-squared:  0.5566 \nF-statistic: 12.92 on 2 and 17 DF,  p-value: 0.0003867\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-31' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-31', 'opt-start-31')\"> <span class=\"olab\">Results Interpretation</span></span></div><div class=\"optional-body\" id = \"opt-body-31\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n## `(Intercept)`   \n\n$\\beta_0$ = `(Intercept)` = 36.16  \n  \n+ The intercept, or predicted recall accuracy when recall confidence was 0 and age was 0.  \n    - An individual aged 0 years with no recall confidence was expected to have a recall accuracy of $36.16$.  \n    \n*Note:* the intercept isn’t very useful here at all. It estimates the accuracy for a newborn (who wouldn’t be able to complete the task!).\n    \n## `recall_confidence`  \n\n$\\beta_1$ = `recall_confidence` = 0.9   \n  \n+ The estimated difference in recall accuracy for each additional unit increase in confidence controlling for age.  \n    - Holding age constant, each 1 additional unit in recall confidence was associated with a significant $0.9$ percentage point increase in recall accuracy $(p < .001)$.  \n    \n## `age`   \n\n$\\beta_2$ = `age` = -0.34   \n  \n+ The estimated difference in recall accuracy for each additional year in age controlling for recall confidence.  \n    - Holding recall confidence constant, every 1 additional year in age was associated with a significant $-0.34$ percentage point decrease in recall accuracy $(p = .041)$.  \n    \n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-32' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-32', 'opt-start-32')\"> <span class=\"olab\">Model Visualisation</span></span></div><div class=\"optional-body\" id = \"opt-body-32\" style=\"display: none;\">\n\n\n\nWhen we have 2+ predictors, we can’t just plot our data an add `geom_smooth(method=lm)`, because that would give a visualisation of a linear model with just one predictor (whichever one is on the $x$-axis).  \n\nInstead, we can use the function `plot_model()` from **sjPlot**.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_model(recall_multi,\n           type = \"eff\",\n           terms = \"recall_confidence\",\n           show.data = TRUE)\n\nplot_model(recall_multi,\n           type = \"eff\",\n           terms = \"age\",\n           show.data = TRUE)\n```\n\n::: {.cell-output-display}\n![Association between Recall Accuracy, Recall Confidence, and Age](1_b2_reading_files/figure-html/fig-recalmod-1.png){#fig-recalmod-1 fig-align='center' width=80%}\n:::\n\n::: {.cell-output-display}\n![Association between Recall Accuracy, Recall Confidence, and Age](1_b2_reading_files/figure-html/fig-recalmod-2.png){#fig-recalmod-2 fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Numeric Outcomes & Categorical Predictors\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-33' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-33', 'opt-start-33')\"> <span class=\"olab\">Overview</span></span></div><div class=\"optional-body\" id = \"opt-body-33\" style=\"display: none;\">\n\n\n\nWe can include categorical predictors in a linear regression, but the interpretation of the coefficients is very specific. Whereas we talked about coefficients being interpreted as “the change in $y$ associated with a 1-unit increase in $x$”, for categorical explanatory variables, coefficients can be considered to examine differences in group means. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-34' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-34', 'opt-start-34')\"> <span class=\"olab\">Coding Variables as Factors</span></span></div><div class=\"optional-body\" id = \"opt-body-34\" style=\"display: none;\">\n\n\n\nWhen we have categorical predictors, it is important that we tell `R` specifically to code them appropriately as *factors*.  \n\n:::blue\n\nIn **R**\n\nWe can use various functions to convert between different types of data, such as:\n\n+ `factor()` / `as_factor()` - to turn a variable into a factor  \n+ `as.numeric()` - to turn a variable into numbers\n\n:::\n\n\n\nAs a first step, it is a good idea to look at the structure of the dataset you are working with. For the purpose of this example, our dataset is called \"tips\" (you might recall this from DAPR1):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(tips)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspc_tbl_ [157 × 7] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ Bill  : num [1:157] 23.7 36.1 32 17.4 15.4 ...\n $ Tip   : num [1:157] 10 7 5.01 3.61 3 2.5 3.44 2.42 3 2 ...\n $ Credit: chr [1:157] \"n\" \"n\" \"y\" \"y\" ...\n $ Guests: num [1:157] 2 3 2 2 2 2 2 2 2 2 ...\n $ Day   : chr [1:157] \"f\" \"f\" \"f\" \"f\" ...\n $ Server: chr [1:157] \"A\" \"B\" \"A\" \"B\" ...\n $ PctTip: num [1:157] 42.2 19.4 15.7 20.8 19.5 13.4 16 12.4 12.7 10.7 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Bill = col_double(),\n  ..   Tip = col_double(),\n  ..   Credit = col_character(),\n  ..   Guests = col_double(),\n  ..   Day = col_character(),\n  ..   Server = col_character(),\n  ..   PctTip = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n:::\n:::\n\n\nFrom the output, we can see that `Credit` (whether guests paid with a credit card; n/y responses) was coded as a `<chr>` or character variable. If we wanted to set this as a factor so that `R` recognises it as a categorical variable, we can use on of the following:\n\n::: {.panel-tabset}\n\n### `as_factor()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntips <- tips |> \n  mutate(Credit = as_factor(Credit))\n```\n:::\n\n\n### `factor()`\n\nWe could also use the `factor()` function, and at the same time label factors appropriately to aid reader interpretation (it may not be immediately clear to some that *n* represents 'No' and *y* represents 'Yes'). To do so, we list the all levels of `Credit`, and provide a new label corresponding to each level:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntips$Credit <- factor(tips$Credit, \n                      levels = c(\"n\", \"y\"),\n                      labels = c(\"No\", \"Yes\"))\n```\n:::\n\n\n:::\n\nUsing either of the above approaches, if we now run `str(tips)` again, you should see that `Credit` is now coded as a factor with 2 levels:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr(tips)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [157 × 7] (S3: tbl_df/tbl/data.frame)\n $ Bill  : num [1:157] 23.7 36.1 32 17.4 15.4 ...\n $ Tip   : num [1:157] 10 7 5.01 3.61 3 2.5 3.44 2.42 3 2 ...\n $ Credit: Factor w/ 2 levels \"n\",\"y\": 1 1 2 2 1 1 1 1 1 1 ...\n $ Guests: num [1:157] 2 3 2 2 2 2 2 2 2 2 ...\n $ Day   : chr [1:157] \"f\" \"f\" \"f\" \"f\" ...\n $ Server: chr [1:157] \"A\" \"B\" \"A\" \"B\" ...\n $ PctTip: num [1:157] 42.2 19.4 15.7 20.8 19.5 13.4 16 12.4 12.7 10.7 ...\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-35' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-35', 'opt-start-35')\"> <span class=\"olab\">Binary Predictors</span></span></div><div class=\"optional-body\" id = \"opt-body-35\" style=\"display: none;\">\n\n\n\nBinary variables have two categories (more commonly referred to as levels), and these levels (e.g., Yes/No, Dog/Cat, Right/Left, Smoker/Non-Smoker) are simply entered in the model as a series of 0s and 1s. Numeric variables that represent categorical data are typically referred to as __dummy variables__.  \n\nOur coefficients are just the same as before. The intercept is where our predictor equals zero, and the slope is the change in our outcome variable associated with a 1-unit change in our predictor.\n\nHowever, “zero” for this predictor variable now corresponds to a whole level. This is known as the “reference level”. Accordingly, the 1-unit change in our predictor (the move from “zero” to “one”) corresponds to the difference between the two levels. \n\nWhen used as predictors in multiple regression models, binary variables behave much the same way. The coefficient will give us the estimated change in $y$ when moving from one level to the other, whilst holding other predictors constant (for more info, see the **Multiple Linear Regression Models - Description & Specification** flashcard, specifically the section on interpretation of multiple regression coefficients).\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-36' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-36', 'opt-start-36')\"> <span class=\"olab\">Categorical Predictors with k levels</span></span></div><div class=\"optional-body\" id = \"opt-body-36\" style=\"display: none;\">\n\n\n\nWhen we have a _categorical_ explanatory variable with __more than 2 levels__, our model gets a bit more complex - it needs not just one, but _a number of_ dummy variables. For a categorical variable with $k$ levels, we can express it in $k-1$ dummy variables.  \n\nFor example, the \"species\" column below has three levels, and can be expressed by the two variables \"species_dog\" and \"species_parrot\": \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n  species species_dog species_parrot\n1     cat           0              0\n2     cat           0              0\n3     dog           1              0\n4  parrot           0              1\n5     dog           1              0\n6     cat           0              0\n7     ...         ...            ...\n```\n:::\n:::\n\n\n+ The \"cat\" level is expressed whenever both the \"species_dog\" and \"species_parrot\" variables are 0.\n+ The \"dog\" level is expressed whenever the \"species_dog\" variable is 1 and the \"species_parrot\" variable is 0.\n+ The \"parrot\" level is expressed whenever the \"species_dog\" variable is 0 and the \"species_parrot\" variable is 1.  \n\n`R` will do all of this re-expression for us. If we include in our model a categorical explanatory variable with 3 different levels, the model will estimate 2 parameters - one for each dummy variable. We can interpret the parameter estimates (the coefficients we obtain using `coefficients()`,`coef()` or `summary()`) as the estimated increase in the outcome variable associated with an increase of one in each dummy variable (holding all other variables equal).  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n-----------------------------------------------------------------\n      &nbsp;         Estimate   Std. Error   t value   Pr(>|t|)  \n------------------- ---------- ------------ --------- -----------\n  **(Intercept)**     60.28       1.209       49.86    5.273e-39 \n\n  **speciesdog**      -11.47       1.71      -6.708    3.806e-08 \n\n **speciesparrot**    -4.916       1.71      -2.875    0.006319  \n-----------------------------------------------------------------\n:::\n:::\n\n\nRecall that the intercept is the estimated outcome when all predictors are zero. In our example then, this represents the cat. We think of the \"cat\" category in this example as the _reference level_ - it is the category against which other categories are compared against. Therefore, in the above example, an increase in 1 of \"species_dog\" is the difference between a \"cat\" and a \"dog\". An increase in one of \"species_parrot\" is the difference between a \"cat\" and a \"parrot\". \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-60-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-37' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-37', 'opt-start-37')\"> <span class=\"olab\">Dummy vs Effects Coding</span></span></div><div class=\"optional-body\" id = \"opt-body-37\" style=\"display: none;\">\n\n\n\n\nPossible side-constraints on the parameters are:\n\n|       Name      |             Constraint            |             Meaning of $\\beta_0$            |         R         |\n|:---------------:|:---------------------------------:|:-------------------------------------------:|:-----------------:|\n| Sum to zero (Effects Coding) | $\\beta_1 + \\beta_2 + \\beta_3 = 0$ | $\\beta_0 = \\mu$   |    `contr.sum`    |\n| Reference group (Dummy Coding) |           $\\beta_1 = 0$           | $\\beta_0 = \\mu_1$ | `contr.treatment` |\n\n\n**Dummy Coding**\n\nBy default `R` uses the reference group constraint - i.e., dummy coding  (sometimes called treatment contrast coding). If your factor has $g$ levels, your regression model will have $g-1$ dummy variables (`R` creates them for you, as we've seen in the examples above). \n\nWhen we use this approach, the intercept is the estimated $y$ when all predictors (i.e., $x$'s) are zero. Because the reference level is kind of like “0” in our contrast matrix, this is part of the intercept estimate. We get out a coefficient for each subsequent level, which are the estimated differences from each level to the reference group.\n\n\n**Effects Coding**\n\nEffects coding (sometimes called sum-to-zero coding) is the next most commonly used in psychological research. These are a way of comparing each level to the overall (or grand) mean. This involves a bit of trickery that uses -1s and 1s rather than 0s and 1s, in order to make “0” be mid-way between all the levels - the average of the levels.\n\nWhen we use this approach, the intercept is the estimated average $y$ when averaged across all levels of the predictor variable. In other words, it is the estimated grand mean of $y$. The coefficients represent the estimated difference for that level from the overall grand mean.\n\n:::blue\n\nIn **R**\n\nIf we want to use effects coding, we can apply:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontrasts(iris$Species) <- \"contr.sum\"\n```\n:::\n\n\nWe can switch back to the default reference group constraint by applying either of these:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Option 1\ncontrasts(iris$Species) <- NULL\n\n# Option 2\ncontrasts(iris$Species) <- \"contr.treatment\"\n```\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-38' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-38', 'opt-start-38')\"> <span class=\"olab\">Specifying Reference Levels</span></span></div><div class=\"optional-body\" id = \"opt-body-38\" style=\"display: none;\">\n\n\n\nWhen you have a categorical variable coded as a factor, `R` will default to using alphabetical ordering - hence in our example above \"cat\" was the reference level (as opposed to \"dog\" or \"parrot\").\n\nWe could override this by making it a factor with an ordering to it’s levels (see the use of `factor()` and `levels()`). Functions like `fct_relevel()` might be handy too. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n#### Example\n\n> **Research Question** \n>\n> Does sepal length differ by species?  \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-39' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-39', 'opt-start-39')\"> <span class=\"olab\">Overview</span></span></div><div class=\"optional-body\" id = \"opt-body-39\" style=\"display: none;\">\n\n\n\nImagine that you were tasked to investigate whether sepal length differs by species. You have been provided with the in-built dataset, `iris`, which contains information concerning the sepal length (in cm), sepal width (in cm), petal length (in cm), and petal width (in cm) from three different species of iris (setosa, versicolor, and virginica). There are measurements for 50 flowers from each of the iris species (i.e., total $n$ = 150). \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-40' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-40', 'opt-start-40')\"> <span class=\"olab\">Visualise Data</span></span></div><div class=\"optional-body\" id = \"opt-body-40\" style=\"display: none;\">\n\n \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(data = iris, aes(x = Species, y = Sepal.Length, fill = Species)) +\n    geom_boxplot() +\n    labs(x = \"Species\", y = \"Sepal Length (in cm)\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-63-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-41' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-41', 'opt-start-41')\"> <span class=\"olab\">Model & Hypothesis Specification</span></span></div><div class=\"optional-body\" id = \"opt-body-41\" style=\"display: none;\">\n\n \n\n::: {.panel-tabset}\n\n### Dummy Coding\n\n::: {.panel-tabset}\n\n#### Model Specification \n\nWe first need to define the dummy variables for Species:\n\n$$\n\\text{Species}_\\text{Versicolor} = \\begin{cases}  \n1 & \\text{if Species is Versicolor} \\\\  \n0 & \\text{otherwise}  \n\\end{cases}  \n\\quad    \n$$\n\n$$\n\\text{Species}_\\text{Virginica} = \\begin{cases}  \n1 & \\text{if Species is Virginica} \\\\  \n0 & \\text{otherwise}  \n\\\\  \n\\end{cases}  \n\\quad  \n$$\n\n\n$$\n(\\text{Species}_\\text{Setosa } \\text{ is the reference level})  \n$$\n\nBased on the above dummy coding, we are going to fit the following regression model:\n\n$$\n\\begin{align}\n\\text{Sepal Length} = \\beta_0 + \\beta_1 \\cdot \\text{Species}_\\text{Versicolor} + \\beta_2 \\cdot \\text{Species}_\\text{Virginica} + \\epsilon\n\\end{align}\n$$\n\n#### Hypothesis Specification \n\n\n$H_0:$ All $\\beta_j = 0$ (for $j = 1, 2$)\n\nThere are no differences in sepal length based on iris species.\n  \n\n$H_1:$ At least one $\\beta_j \\neq  0$ (for $j = 1, 2$)\n\nThere are differences in sepal length based on iris species.\n\n\n:::\n\n\n### Effects Coding\n\n::: {.panel-tabset}\n\n#### Model Specification \n\nWe first need to define the effects coding for Species:\n\n$$\n\\begin{matrix}\n\\textbf{Level}           & \\textbf{Effect Level 1} & \\textbf{Effect Level 2} \\\\\n\\hline\n\\text{Setosa}              & 1   & 0    \\\\\n\\text{Versicolor}               & 0   & 1    \\\\\n\\text{Virginica}         & -1  & -1 \\\\\n\\end{matrix}\n$$\n\n\nBased on the above effects coding, we are going to fit the following regression model:\n\n$$\n\\begin{align}\n\\text{Sepal Length} = \\beta_0 + \\beta_1 \\cdot \\text{Effect Level 1} + \\beta_2 \\cdot \\text{Effect Level 2} + \\epsilon\n\\end{align}\n$$\n\n#### Hypothesis Specification \n\n\n$H_0:$ All $\\beta_j = 0$ (for $j = 1, 2$)\n\nThere are no differences in average sepal length based on iris species (i.e., the average sepal length across species is equal to the grand mean).\n  \n\n$H_1:$ At least one $\\beta_j \\neq  0$ (for $j = 1, 2$)\n\nThere are differences in average sepal length based on iris species (i.e., the average sepal length across species is not equal to the grand mean).\n\n\n:::\n\n\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-42' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-42', 'opt-start-42')\"> <span class=\"olab\">Model Building</span></span></div><div class=\"optional-body\" id = \"opt-body-42\" style=\"display: none;\">\n\n \n\n::: {.panel-tabset}\n\n### Dummy Coding\n\nFirst we need to check the levels of the `Species` variable: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#check what levels we have\nlevels(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n:::\n:::\n\n\nFrom the above, we can see that Species has 3 levels - \"setosa\", \"versicolor\", and \"virginica\".  \n  \nIf we put these into a model, assuming `R`'s default ordering, we know that `R` will automatically apply dummy (or treatment coding, i.e., `contrasts(iris$Species) <- \"contr.treatment\"`), and \"setosa\" will be taken as our reference group:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#fit model\nspec_model <- lm(Sepal.Length ~ Species, data = iris)\nsummary(spec_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = Sepal.Length ~ Species, data = iris)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.6880 -0.3285 -0.0060  0.3120  1.3120 \n\nCoefficients:\n                  Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         5.0060     0.0728  68.762  < 2e-16 ***\nSpeciesversicolor   0.9300     0.1030   9.033 8.77e-16 ***\nSpeciesvirginica    1.5820     0.1030  15.366  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5148 on 147 degrees of freedom\nMultiple R-squared:  0.6187,\tAdjusted R-squared:  0.6135 \nF-statistic: 119.3 on 2 and 147 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\n### Effects Coding\n\nFirst we need to tell `R` to apply effects (or sum-to-zero) coding and check the ordering of the levels:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncontrasts(iris$Species) <- \"contr.sum\"\ncontrasts(iris$Species) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1] [,2]\nsetosa        1    0\nversicolor    0    1\nvirginica    -1   -1\n```\n:::\n:::\n\n\nThen we can run our model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#fit model\nspec_model2 <- lm(Sepal.Length ~ Species, data = iris)\nsummary(spec_model2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = Sepal.Length ~ Species, data = iris)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.6880 -0.3285 -0.0060  0.3120  1.3120 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  5.84333    0.04203 139.020   <2e-16 ***\nSpecies1    -0.83733    0.05944 -14.086   <2e-16 ***\nSpecies2     0.09267    0.05944   1.559    0.121    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5148 on 147 degrees of freedom\nMultiple R-squared:  0.6187,\tAdjusted R-squared:  0.6135 \nF-statistic: 119.3 on 2 and 147 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-43' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-43', 'opt-start-43')\"> <span class=\"olab\">Results Interpretation</span></span></div><div class=\"optional-body\" id = \"opt-body-43\" style=\"display: none;\">\n\n \n\n::: {.panel-tabset}\n\n### Dummy Coding\n\n| Coefficient | Estimate | Corresponds to |\n|:-:|:-:|:-:|\n| (Intercept)   |  5.0060 | $\\beta_0 = \\hat \\mu_1$\n| Speciesversicolor      | 0.9300  | $\\beta_0 + \\beta_1 = \\hat \\mu_2$ |\n| Speciesvirginica         | 1.5820  | $\\beta_0 + \\beta_2 = \\hat \\mu_3$ |\n\n+ The estimate corresponding to (Intercept) contains $\\hat \\beta_0 = \\hat \\mu_1 = 5.01$. The estimated average sepal length for the species setosa was approximately 5.01.\n\n+ The second estimate corresponds to `Speciesversicolor` and was $\\hat \\beta_1 = 0.93$. The difference in mean sepal length between `setosa` and `versicolor` species was estimated to be $0.93~cm$. Thus, $\\hat \\mu_2 = 5.01 + 0.93 = 5.94$. We could say - the species iris versicolor had a sepal length of approximately 5.94cm, and this was approximately 0.93cm longer than the iris setosa. This difference was statistically significant $(p < .001)$.\n\n+ The third estimate corresponds to `Speciesvirginica` and was $\\hat \\beta_2 = 1.58$. The difference in mean sepal length between `setosa` and `virginica` species was estimated to be $1.58~cm$. Thus, $\\hat \\mu_2 = 5.01 + 1.58 = 6.59$. We could say - the species iris virginica had a sepal length of approximately 6.59cm, and this was approximately 1.58cm longer than the iris setosa. This difference was statistically significant $(p < .001)$.\n\n\n### Effects Coding\n\n| Coefficient | Estimate | Corresponds to |\n|:-:|:-:|:-:|\n| (Intercept)   |  5.84333  | $\\beta_0 = \\frac{\\mu_1 + \\mu_2 + \\mu_3}{3} = \\mu$\n| Species1      | -0.83733  | $\\beta_1 = \\mu_1 - \\mu$|\n| Species2      | 0.09267   | $\\beta_2 = \\mu_2 - \\mu$ |\n\n+ The first estimate corresponding to (Intercept) contains $\\hat \\beta_0 = \\hat \\mu = 5.84$. The estimated average sepal length across iris species was approximately $5.84~cm$.\n\n+ The second estimate corresponds to `Species1` and was $\\hat \\beta_1 = -0.84$. The difference in mean sepal length between `setosa` $(\\hat \\mu_1)$ and the grand mean $(\\hat \\mu_0)$  was estimated to be $0.84~cm$. In other words, the iris species of setosa had a sepal length $0.84~cm$ shorter than average, where its length was estimated to be $5.84333 + (-0.83733) = 5~cm$. This difference in length was statistically significant $(p < .001)$.\n\n+ The third estimate corresponds to `Species2` and was $\\hat \\beta_2 = 0.09$. The difference in mean sepal length between `versicolor` $(\\hat \\mu_2)$ and the grand mean $(\\hat \\mu_0)$  was estimated to be $0.09~cm$. In other words, the iris species of versicolor had a sepal length $0.09~cm$ longer than average, where its length was estimated to be $5.84333 + 0.09267 = 5.94~cm$. This difference in length was not statistically significant $(p = .121)$.\n\n+ The estimate for `Species3`, representing the difference of “virginica” to the grand mean is *not shown* by `summary()`. Because of the side-constraint, we know that $\\mu_3 = \\beta_0 - (\\beta_1 + \\beta_2)$. The difference in sepal length between `virginica` and the grand mean was estimated to be $-(-0.83733 + 0.09267) = 0.74466$. In other words, the virginica iris species had a sepal length $0.74~cm$ longer than average, where its length was estimated to be $5.84333 - (-0.83733  + 0.09267) = 6.59~cm$.  \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-44' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-44', 'opt-start-44')\"> <span class=\"olab\">Model Visualisation</span></span></div><div class=\"optional-body\" id = \"opt-body-44\" style=\"display: none;\">\n\n \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-45' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-45', 'opt-start-45')\"> <span class=\"olab\">Specifying Reference Levels</span></span></div><div class=\"optional-body\" id = \"opt-body-45\" style=\"display: none;\">\n\n\n\nLet's say we wanted to change the reference level in our \"spec_model\" above, there are a few different ways that we can do this.\n\nFirst we should check the current ordering of the levels:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlevels(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n:::\n:::\n\n\nWe can then change the reference level to be \"versicolor\" (using one of the below methods):\n\n::: {.panel-tabset}\n\n### `fct_relevel()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris <- iris |> \n  mutate(\n    Species = fct_relevel(Species, \"versicolor\")\n  )\n```\n:::\n\n\n\n### `relevel()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris$Species <- relevel(iris$Species, \"versicolor\")\n```\n:::\n\n\n### `factor()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\niris$Species <- iris$Species |> \n  factor(., levels = c(\"versicolor\", \"setosa\", \"virginica\"))\n```\n:::\n\n\n:::\n\nAnd then re-run our model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#fit model\nspec_model2 <- lm(Sepal.Length ~ Species, data = iris)\nsummary(spec_model2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = Sepal.Length ~ Species, data = iris)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.6880 -0.3285 -0.0060  0.3120  1.3120 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  5.84333    0.04203 139.020   <2e-16 ***\nSpecies1     0.09267    0.05944   1.559    0.121    \nSpecies2    -0.83733    0.05944 -14.086   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.5148 on 147 degrees of freedom\nMultiple R-squared:  0.6187,\tAdjusted R-squared:  0.6135 \nF-statistic: 119.3 on 2 and 147 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## General - Extracting Information\n\nIt is important to have a good grasp of how to understand and interpret the key components of your model `summary()` output, including model coefficients, standard errors, $t$-values, $p$-values, etc., and how these can be used in further calculations (such as confidence intervals). As well as knowing how to extract from `R`, it is necessary to understand how to compute some of these statistics by hand too. \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-46' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-46', 'opt-start-46')\"> <span class=\"olab\">Model Call</span></span></div><div class=\"optional-body\" id = \"opt-body-46\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, model formula highlighted](images/recall_mdl_call_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\nThe call section at the very top of the `summary()` output shows us the formula that was specified in `R` to fit the regression model.\n\nIn the above, we can see that recall accuracy is our DV, recall confidence and age were our two IVs, and our dataset was named recalldata.\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-47' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-47', 'opt-start-47')\"> <span class=\"olab\">Residuals</span></span></div><div class=\"optional-body\" id = \"opt-body-47\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, residuals highlighted](images/recall_mdl_residuals_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n  \nResiduals are the difference between the observed values and model predicted values of the DV. \n  \nIdeally, for the model to be unbiased, we want our median value (the middle value of the residuals when ordered) to be around 0, as this would show that the errors are random fluctuations around the true line. When this is the case, we know that our model is doing a good job predicting values at the high and low ends of our dataset, and that our residuals were somewhat symmetrical. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-48' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-48', 'opt-start-48')\"> <span class=\"olab\">Model Coefficients</span></span></div><div class=\"optional-body\" id = \"opt-body-48\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, model coefficients highlighted](images/recall_mdl_coefficients_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\n::: {.panel-tabset}\n\n### Estimates\n\nOur model estimates help us to build our best fitting equation of the line that represents the association between our DV and our IV(s). \n\nIn the above example, we can build our equation for our model from this information:\n\n$$\n\\text{Recall Accuracy}_i = \\beta_0 + \\beta_1 \\cdot \\text{Recall Confidence}_i + \\beta_2 \\cdot \\text{Age}_i + \\epsilon_i\n$$\n$$\n\\widehat{\\text{Recall Accuracy}} = 36.16 + 0.90 \\cdot \\text{Recall Confidence} - 0.34 \\cdot \\text{Age} \n$$\n\n\n**How to calculate $\\hat \\beta_0$ and $\\hat \\beta_1$**\n\n::: {.panel-tabset}\n\n### By Hand\n\nLet's apply to a straightforward example to try by-hand. Suppose you have a simple linear regression model (i.e., with only one IV) where you have the following data points:\n\n\n| Observed   $x_i$   | Observed   $y_i$   |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\n\n**Step 1: Calculate mean of both $x$ and $y$**\n\n$\\bar x = {\\frac{1+2+3+4+5}{5}} = 3$\n\n$\\bar y = {\\frac{5+7+8+6+9}{5}} = 7$\n\n**Step 2: Calculate $\\beta_0$ and $\\beta_1$**\n\nWe need to calculate the slope first, as we need to know the value of $\\beta_1$ in order to calculate $\\beta_0$\n\n__Slope ($\\beta_1$)__   \n\n$$\n\\begin{align}\n& \\hat \\beta_1 = \\frac{SP_{xy}}{SS_x} \\\\  \n\\\\ \n\\\\ \n& \\text{Where}: \\\\ \n& \\text{SP}_\\text{xy} = \\text{sum of cross-products:} \\\\\n& \\text{SP}_\\text{xy} = \\sum_{i = 1}^{n}(x_i - \\bar{x})(y_i - \\bar{y}) \\\\  \n& \\text{and} \\\\ \n& \\text{SS}_\\text{x} = \\text{sums of squared deviations of x:} \\\\    \n& \\text{SS}_\\text{x} = \\sum_{i = 1}^{n}(x_i - \\bar{x})^2 \\\\  \n\\end{align}\n$$\n\n\n$$\n\\begin{align}\n&\\text{SP}_\\text{xy} =\\sum_{i = 1}^{n}(x_i - \\bar{x})(y_i - \\bar{y}) = \\\\\n& (1-3)(5-7) + (2-3)(7-7) + (3-3)(8-7) + (4-3)(6-7) + (5-3)(9-7) = \\\\\n& 4 + 0 + 0 + (-1) + 4 = \\\\\n& 7 \\\\\n\\\\  \n& \\text{SS}_\\text{x}= \\sum_{i = 1}^{n}(x_i - \\bar{x})^2 = \\\\\n& (1-3)^2 + (2-3)^2 + (3-3)^22 + (4-3)^2 + (5-3)^2 = \\\\\n& 4 + 1 + 0 + 1 + 4 = \\\\\n& 10 \\\\\n\\\\  \n& \\hat \\beta_1 = \\frac{SP_{xy}}{SS_x} = \\frac{7}{10} = 0.7 \\\\\n\\end{align}\n$$\n\n__Intercept ($\\beta_0$)__ \n\n$$\n\\begin{align}\n&\\hat \\beta_0 = \\bar{y} - \\hat \\beta_1 \\bar{x} \\\\\n&\\hat \\beta_0 = 7 - 0.7 \\cdot 3 \\\\\n&\\hat \\beta_0 = 7 - 2.1 \\\\\n&\\hat \\beta_0 = 4.9\n\\end{align}\n$$\n\n### Using R\n\n:::blue\n**In R**\n\nThere are numerous equivalent ways to obtain the estimated regression coefficients --- that is, $\\hat \\beta_0$, $\\hat \\beta_1$, ...., $\\hat \\beta_k$ --- from the fitted model (for this below example, our fitted model has been named `mdl`):\n\n- `mdl`\n- `mdl$coefficients`\n- `coef(mdl)`\n- `coefficients(mdl)`\n\n:::\n\n:::\n\n### Std. Error\n\nThe standard error of the coefficient is an estimate of the standard deviation of the coefficient (i.e., how much uncertainty there is in our estimated coefficient).\n\nThe formula for the standard error of the slope is:\n\n$$\n\\begin{align}\n& SE(\\hat \\beta_j) = \\sqrt{\\frac{\\text{SS}_\\text{Residual}/(n-k-1)}{\\sum(x_{ij} - \\bar{x_{j}})^2(1-R_{xj}^2)}} \\\\  \n\\\\  \n& \\text{Where}: \\\\  \n\\\\  \n& \\text{SS}_\\text{Residual} = \\text{ residual sum of squares} \\\\  \n& n = \\text{ sample size} \\\\  \n& k = \\text{ number of predictors} \\\\  \n& x_{ij} = \\text{ the observed value of a predictor (j) for an individual (i)} \\\\  \n& \\bar{x_{j}} = \\text{the mean of a predictor (j)} \\\\  \n& R_{xj}^2 = \\text{the multiple correlation coefficient of the predictors} \\\\  \n\\end{align}\n$$\n\nLet's apply to a straightforward example. Suppose you have a simple linear regression model (i.e., with only one IV, which means that $R_{xj}^2 = 0$ since there is only one predictor) and the following data points:\n\n\n| Observed   $x_i$   | Observed   $y_i$   |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\n\nThere are a number of steps you need to take to calculate by hand:\n\n1. Calculate sum of the squared residuals  \n    1. Calculate predicted values  \n    2. Calculate residuals (i.e., the difference between the observed value ($y_i$) and the predicted value ($\\hat{y}_i$) for each observation)  \n    3. Square the residuals   \n    4. Calculate the Sum of Squared Residuals  \n2. Calculate the sum of squared deviations of the ($x$) values from their mean\n3. Use values from 1 & 2 to calculate $SE(\\hat \\beta_j)$\n\n**Step 1.1: Calculate predicted values**\n\nUsing $\\hat{y}_i = \\beta_0 + \\beta_1 \\cdot x_i$ and our model coefficients $\\beta_0 = 4.9$ and $\\beta_1 = 0.7$:\n\n\n| Observed  ($x_i$)  | Observed  ($y_i$)  | Predicted ($\\hat{y}_i$) |\n|--------------------|--------------------|-------------------------|\n|         1          |           5        |  4.9 + (0.7*1) = 5.6    |\n|         2          |           7        |  4.9 + (0.7*2) = 6.3    |\n|         3          |           8        |  4.9 + (0.7*3) = 7      |\n|         4          |           6        |  4.9 + (0.7*4) = 7.7    |\n|         5          |           9        |  4.9 + (0.7*5) = 8.4    |\n\n\n**Step 1.2: Calculate residuals**\n\n+ $\\epsilon_1 = 5 − 5.6 = -0.6$\n+ $\\epsilon_2 = 7 - 6.3 = 0.7$\n+ $\\epsilon_3 = 8 - 7 = 1$\n+ $\\epsilon_4 = 6 - 7.7 = -1.7$\n+ $\\epsilon_5 = 9 − 8.4 = 0.6$\n\n**Step 1.3: Square the residuals**\n\n+ $\\epsilon_1^2 = -0.6^2 = 0.36$\n+ $\\epsilon_2^2 = 0.7^2 = 0.49$\n+ $\\epsilon_3^2 = 1^2 = 1$\n+ $\\epsilon_4^2 = -1.7^2 = 2.89$\n+ $\\epsilon_5^2 = 0.6^2 = 0.36$\n\n**Step 1.4: Calculate the Sum of Squared Residuals**\n\n$$\n\\sum \\epsilon_i^2 = 0.36 + 0.49 + 1 + 2.89 + 0.36 = 5.1\n$$\n\n**Step 2. Calculate the sum of squared deviations of the ($x$) values from their mean**\n\nThe mean of $x$ can be calculated as: $\\bar x = {\\frac{1+2+3+4+5}{5}} = 3$. Using this, we can then calculate the sum of squared deviations of $x$:\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n}(x_i - \\bar{x})^2 = \\\\\n& (1-3)^2 + (2-3)^2 + (3-3)^22 + (4-3)^2 + (5-3)^2 = \\\\\n& 4 + 1 + 0 + 1 + 4 = \\\\\n& 10 \\\\\n\\end{align}\n$$\n\n**Step 3: Calculate $SE(\\hat \\beta_j)$** \n\nFrom this, we can finally calculate $SE(\\hat \\beta_j)$:\n\n$$\n\\begin{align}\n& SE(\\hat \\beta_j) = \\sqrt{\\frac{\\text{SS}_\\text{Residual}/(n-k-1)}{\\sum(x_{ij} - \\bar{x_{j}})^2(1-R_{xj}^2)}} \\\\  \n& SE(\\hat \\beta_j) = \\sqrt{\\frac{5.1/(5-1-1)}{10 \\cdot (1-0)}} \\\\ \n& SE(\\hat \\beta_j) = \\sqrt{\\frac{5.1/3}{10}} \\\\ \n& SE(\\hat \\beta_j) = \\sqrt{\\frac{1.7}{10}} \\\\ \n& SE(\\hat \\beta_j) = \\sqrt{0.17} \\\\ \n& SE(\\hat \\beta_j) = 0.4207\n\\\\\n\\end{align}\n$$\n\n\n:::blue\n**In R**\n\nIf you wanted to obtain just the standard error for each estimated regression coefficient, you could do the following (for this below example, our fitted model has been named `mdl`):\n\n- `summary(mdl)$coefficients[,2]` \n\n:::\n\n### t value\n\nThe t-statistic is the $\\beta$ coefficient divided by the standard error: \n\n$$\nt = \\frac{\\hat \\beta_j - 0}{SE(\\hat \\beta_j)}\n$$\n\nwhich follows a $t$-distribution with $n-k-1$ degrees of freedom (where $k$ = number of predictors and $n$ = sample size).\n\nWith this, we can test the the null hypothesis $H_0: \\beta_j = 0$. \n\nGenerally speaking, you want your model coefficients to have large $t$-statistics as this would indicate that the standard error was small in comparison to the coefficient. The larger our $t$-statistic, the more confident we can be that the coefficient is not 0. \n\n**How to calculate $t = \\frac{\\hat \\beta_j - 0}{SE(\\hat \\beta_j)}$**\n\n::: {.panel-tabset}\n\n### By Hand\n\nWe can calculate the test statistic $t$ for $\\beta_\\text{Age}$ (or $\\beta_2$) by hand from our `recall_multi` model as follows:\n\n$$\n\\begin{align}\n\\\\\n& t = \\frac{\\hat \\beta_j - 0}{SE(\\hat \\beta_j)} \\\\  \n\\\\  \n& t = \\frac{-0.3392 - 0}{0.1534} \\\\ \n\\\\  \n& t = -2.211213 \\\\  \n\\\\  \n& t = -2.21 \\\\  \n\\end{align}\n$$\n\nWe then need to calculate $t^*$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn <- nrow(recalldata)\nk <- 2\ntstar <- qt(0.975, df = n - k - 1)\ntstar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.109816\n```\n:::\n:::\n\n\nAnd finally compare $|t|$ to $t^*$. Since $|t|$ is larger than $t^*$ (-2.21 > 2.11), we can reject the null hypothesis. \n\n\n### In R\n\n:::blue\n**In R**\n\nIf you wanted to obtain just the $t$-values for each estimated regression coefficient, you could use the following:\n\n- `coef(summary(mdl))[, \"t value\"]`\n- `summary(mdl)$coefficients[,3]` \n\nFor example:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncoef(summary(recall_multi))[, \"t value\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      (Intercept) recall_confidence               age \n         2.815890          4.684654         -2.211515 \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(recall_multi)$coefficients[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      (Intercept) recall_confidence               age \n         2.815890          4.684654         -2.211515 \n```\n:::\n:::\n\n\n:::\n\n:::\n\n### Pr(>|t|)\n\nFrom our $t$-value, we can compute our $p$-value. The $p$-value help us to understand whether our coefficient(s) are statistically significant (i.e., that the coefficient is statistically different from 0). The $p$-value of each estimate indicates the probability of observing a $t$-value at least as extreme as, or more extreme than, the one calculated from the sample data when assuming the null hypothesis to be true.\n\nIn Psychology, a $p$-value < .05 is usually used to make statements regarding statistical significance (it is important that you always state your $\\alpha$ level to help your reader understand any statements regarding statistical significance).\n\nThe number of asterisks marks corresponds with the significance of the coefficient (see the 'Signif. codes' legend just under the coefficients section). \n\n:::blue\n**In R**\n\nIf you wanted to obtain just the $p$-values for each estimated regression coefficient, you could do the following (for this below example, our fitted model has been named `mdl`):\n\n- `summary(mdl)$coefficients[,4]` \n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-49' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-49', 'opt-start-49')\"> <span class=\"olab\">Confidence Intervals</span></span></div><div class=\"optional-body\" id = \"opt-body-49\" style=\"display: none;\">\n\n\n\nUsing the estimate and standard error of a given $\\beta$ coefficient, we can create confidence intervals to estimate a plausible range of values for the true population parameter. Recall the formula for obtaining a confidence interval for the population slope is:\n\n$$\n\\hat \\beta_j \\pm t^* \\cdot SE(\\hat \\beta_j)\n$$\n\nwhere $t^*$ denotes the critical value chosen from $t$-distribution with $n-k-1$ degrees of freedom (where $k$ = number of predictors and $n$ = sample size) for a desired $\\alpha$ level of confidence. \n\n**How to calculate $\\hat \\beta_j \\pm t^* \\cdot SE(\\hat \\beta_j)$**\n\n::: {.panel-tabset}\n\n### By Hand\n\nTo calculate by hand for $\\hat \\beta_\\text{Age}$ from our `recall_multi` model, we first need to calculate $t^*$:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn <- nrow(recalldata)\nk <- 2\ntstar <- qt(0.975, df = n - k - 1)\ntstar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.109816\n```\n:::\n:::\n\n\nFor 95% confidence intervals, we  use $t^* = 2.1098$, and can simply substitute into the formula:\n\n$$\n\\begin{align}\n& \\text{Lower CI} = \\hat \\beta_\\text{Age} - t^* \\cdot SE(\\hat \\beta_\\text{Age}) \\\\  \n& \\text{Lower CI} = -0.3392 - (2.1098 \\cdot 0.1534) \\\\  \n& \\text{Lower CI} = -0.6628433 \\\\\n& \\text{Lower CI} = -0.663 \\\\\n\\\\    \n& \\text{Upper CI} = \\hat \\beta_\\text{Age} + t^* \\cdot SE(\\hat \\beta_\\text{Age}) \\\\  \n& \\text{Upper CI} = -0.3392 + (2.1098 \\cdot 0.1534) \\\\ \n& \\text{Upper CI} = -0.01555668 \\\\\n& \\text{Upper CI} = -0.016 \\\\\n\\end{align}\n$$\n\n\n### Using R\n\n:::blue\n**In R**\n\nWe can obtain the confidence intervals for the regression coefficients using the command `confint()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nconfint(recall_multi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       2.5 %      97.5 %\n(Intercept)        9.0668871 63.25228524\nrecall_confidence  0.4923220  1.29913640\nage               -0.6627188 -0.01559663\n```\n:::\n:::\n\n\nOr alternatively use `R` to compute using the manual process (though it makes more sense to use `confint()` given it is less prone to typos!):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntibble(\n  b2_LowerCI = round(-0.3392 - (qt(0.975, n-3) * 0.1534), 3),\n  b2_UpperCI = round(-0.3392 + (qt(0.975, n-3) * 0.1534), 3)\n      )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  b2_LowerCI b2_UpperCI\n       <dbl>      <dbl>\n1     -0.663     -0.016\n```\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-50' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-50', 'opt-start-50')\"> <span class=\"olab\">$\\sigma$</span></span></div><div class=\"optional-body\" id = \"opt-body-50\" style=\"display: none;\">\n\n\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, model standard deviation of the errors highlighted](images/recall_mdl_residerror_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\nThe standard deviation of the errors, denoted by $\\sigma$, is an important quantity that our model estimates. It represents how much individual data points tend to deviate above and below the regression line - in other words, it tells us how well the model fits the data. \n\nA small $\\sigma$ indicates that the points hug the line closely and we should expect fairly accurate predictions, while a large $\\sigma$ suggests that, even if we estimate the line perfectly, we can expect individual values to deviate from it by substantial amounts.\n\nThe *estimated* standard deviation of the errors is denoted $\\hat \\sigma$, and is estimated by essentially averaging squared residuals (giving the variance) and taking the square-root: \n\n$$\n\\begin{align}\n& \\hat \\sigma = \\sqrt{\\frac{\\text{SS}_\\text{Residual}}{n - k - 1}} \\\\\n\\qquad \\\\\n& \\text{Where:}  \\\\\n& \\text{SS}_\\text{Residual} = \\textrm{Sum of Squared Residuals} = \\sum_{i=1}^n{(\\epsilon_i)^2} \\\\\n\\\\  \n\\\\  \n& \\text{and so, equivalently:} \\\\  \n\\\\  \n& \\hat \\sigma = \\sqrt{\\frac{\\sum_{i=1}^{n}(y_i - \\hat{y}_i)^2}{n - k - 1}} \\\\\n\\end{align}\n$$\n  \n  \n**How to calculate $\\hat \\sigma$**\n\n::: {.panel-tabset}\n\n### By Hand\n\nThere are a number of steps you need to take to calculate by hand:\n\n1. Calculate predicted values\n2. Calculate residuals (i.e., the difference between the observed value ($y_i$) and the predicted value ($\\hat{y}_i$) for each observation)  \n3. Square the residuals  \n4. Calculate the Sum of Squared Residuals  \n5. Determine the Residual Standard Deviation ($\\sigma$)  \n\nLet's apply to a straightforward example. Suppose you have a simple linear regression model (i.e., with only one IV) and the following data points:\n\n| Observed  ($x_i$)  | Observed  ($y_i$)  |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\n**Step 1: Calculate predicted values**\n\nUsing $\\hat{y}_i = \\beta_0 + \\beta_1 \\cdot x_i$ and our model coefficients $\\beta_0 = 4.9$ and $\\beta_1 = 0.7$:\n\n\n| Observed  ($x_i$)  | Observed  ($y_i$)  | Predicted ($\\hat{y}_i$) |\n|--------------------|--------------------|-------------------------|\n|         1          |           5        |  4.9 + (0.7*1) = 5.6    |\n|         2          |           7        |  4.9 + (0.7*2) = 6.3    |\n|         3          |           8        |  4.9 + (0.7*3) = 7      |\n|         4          |           6        |  4.9 + (0.7*4) = 7.7    |\n|         5          |           9        |  4.9 + (0.7*5) = 8.4    |\n\n\n**Step 2: Calculate residuals**\n\n+ $\\epsilon_1 = 5 − 5.6 = -0.6$\n+ $\\epsilon_2 = 7 - 6.3 = 0.7$\n+ $\\epsilon_3 = 8 - 7 = 1$\n+ $\\epsilon_4 = 6 - 7.7 = -1.7$\n+ $\\epsilon_5 = 9 − 8.4 = 0.6$\n\n**Step 3: Square the residuals**\n\n+ $\\epsilon_1^2 = -0.6^2 = 0.36$\n+ $\\epsilon_2^2 = 0.7^2 = 0.49$\n+ $\\epsilon_3^2 = 1^2 = 1$\n+ $\\epsilon_4^2 = -1.7^2 = 2.89$\n+ $\\epsilon_5^2 = 0.6^2 = 0.36$\n\n**Step 4: Calculate the Sum of Squared Residuals**\n\n$$\n\\sum \\epsilon_i^2 = 0.36 + 0.49 + 1 + 2.89 + 0.36 = 5.1\n$$\n\n**Step 5: Determine the Residual Standard Deviation ($\\sigma$)**\n\n$$\n\\begin{align}\n& \\hat \\sigma = \\sqrt{\\frac{\\text{SS}_\\text{Residual}}{n - k - 1}} \\\\  \n\\\\   \n& \\hat \\sigma = \\sqrt{\\frac{5.1}{5 - 1 - 1}}  \\\\  \n\\\\   \n& \\hat \\sigma = \\sqrt{\\frac{5.1}{3}}  \\\\  \n\\\\   \n& \\hat \\sigma = \\sqrt{1.70}  \\\\    \n\\\\  \n& \\hat \\sigma = 1.304  \\\\  \n\\end{align}\n$$\n\n### Using R\n\n:::blue\n\n**In R**\n\nThere are a couple of equivalent ways to obtain the estimated standard deviation of the errors --- that is, $\\hat \\sigma$ --- from the fitted model (for this example, our fitted model has been named `mdl`):\n\n- `sigma(mdl)`\n- `summary(mdl)`\n\n::: \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Manual Contrasts\n\nDummy and effects coding allow us to  test the significance of the difference between means of groups and some other mean (either reference group or grand mean respectively). However, in some cases, we may want to test more specific hypotheses that require us to test the difference between particular *combinations* of groups. In such cases, we can use manual contrasts.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-51' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-51', 'opt-start-51')\"> <span class=\"olab\">Rules</span></span></div><div class=\"optional-body\" id = \"opt-body-51\" style=\"display: none;\">\n\n\n\nThere are some rules that we need to follow when using manual contrasts:\n\n+ **Rule 1**: Weights are -1 $\\geq$ x $\\leq$ 1\n+ **Rule 2**: The group(s) in one chunk are given negative weights, the group(s) in the other get positive weights\n+ **Rule 3**: The sum of the weights of the comparison must be 0\n+ **Rule 4**: If a group is not involved in the comparison, weight is 0\n+ **Rule 5**: For a given comparison, weights assigned to group(s) are equal to 1 divided by the number of groups in that chunk.\n+ **Rule 6**: Restrict yourself to running $k$ - 1 comparisons (where $k$ = number of groups)\n+ **Rule 7**: Each contrast can only compare 2 chunks of variance\n+ **Rule 8**: Once a group singled out, it can not enter other contrasts \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-52' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-52', 'opt-start-52')\"> <span class=\"olab\">In R - Additive Model</span></span></div><div class=\"optional-body\" id = \"opt-body-52\" style=\"display: none;\">\n\n\n\nAfter specifying our hypotheses, to test our contrasts, we can use the **emmeans** package and follow the below structure:\n\n+ **Step 1**: Fit and run the model using `lm()`\n+ **Step 2**: Use the `emmeans()` function to obtain the estimated means of each group. You can visualise these by using `plot()` on the obtained  estimated means of the groups\n+ **Step 3**: Check the order of your levels via `levels()`\n+ **Step 4**: Define the contrast by specifying the weights following the rules outlined above (as well as paying attention to the ordering of the levels)\n+ **Step 5**: Test the pre-specified group contrast(s) via `contrast()` \n+ **Step 6**: Obtain confidence intervals via `confint()`\n\nAfter completing these steps, the last task would be to interpret the results of the contrast analysis in the context of the hypothesis. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-53' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-53', 'opt-start-53')\"> <span class=\"olab\">Example - Additive Model</span></span></div><div class=\"optional-body\" id = \"opt-body-53\" style=\"display: none;\">\n\n\n\nSuppose we wanted to address the following question:\n\n> **Research Question** \n>\n> Does the sepal length of an iris grown in Western states (i.e., iris setosa) differ from the sepal length of an Iris grown in Eastern states (i.e., iris versicolor and virginica)?\n\n\nWe could specify our hypothesis as:\n\n$$\n\\begin{aligned}\n    \\quad H_0 &: \\mu_\\text{Western} = \\mu_\\text{Eastern} \\\\\n    \\quad H_0 &: \\mu_\\text{Setosa} = \\frac{1}{2} (\\mu_\\text{Versicolor} + \\mu_\\text{Virginica}) \\\\\n\\\\\n    \\quad H_1 &: \\mu_\\text{Western} \\neq \\mu_\\text{Eastern} \\\\\n    \\quad H_1 &: \\mu_\\text{Setosa} \\neq \\frac{1}{2} (\\mu_\\text{Versicolor} + \\mu_\\text{Virginica}) \\\\\n\\\\ \n\\end{aligned}\n$$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nAnd then conduct our manual contrast analysis:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 1: Fit and run the model \nspec_model <- lm(Sepal.Length ~ Species, data = iris)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 2: Use`emmeans()`& `plot()`\nlibrary(emmeans)\nseplength_mean <- emmeans(spec_model, ~ Species)\nseplength_mean \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Species    emmean     SE  df lower.CL upper.CL\n setosa       5.01 0.0728 147     4.86     5.15\n versicolor   5.94 0.0728 147     5.79     6.08\n virginica    6.59 0.0728 147     6.44     6.73\n\nConfidence level used: 0.95 \n```\n:::\n\n```{.r .cell-code}\nplot(seplength_mean)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-81-1.png){fig-align='center' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 3: Check levels order via `levels()`\nlevels(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 4: Define contrast & weights - want to compare Iris setosa to iris versicolor and iris virginica\nseplength_comp <- list(\"Western State Iris - Eastern State Iris\" = c(-1, 1/2, 1/2))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 5: run contrast analysis\nseplength_comp_test <- contrast(seplength_mean, method = seplength_comp)\nseplength_comp_test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n contrast                                estimate     SE  df t.ratio p.value\n Western State Iris - Eastern State Iris     1.26 0.0892 147  14.086  <.0001\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Step 6: confidence intervals\nconfint(seplength_comp_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n contrast                                estimate     SE  df lower.CL upper.CL\n Western State Iris - Eastern State Iris     1.26 0.0892 147     1.08     1.43\n\nConfidence level used: 0.95 \n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Bonus Step: Run inferential test and return CIs in one command\nsummary(seplength_comp_test, infer = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n contrast                                estimate     SE  df lower.CL upper.CL\n Western State Iris - Eastern State Iris     1.26 0.0892 147     1.08     1.43\n t.ratio p.value\n  14.086  <.0001\n\nConfidence level used: 0.95 \n```\n:::\n:::\n\n\nAnd write up our findings in the context of the hypothesis / research question:\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nWe performed a test against $H_0: \\mu_1 - \\frac{1}{2}(\\mu_2 + \\mu_3) = 0$. At the 5\\% significance level, there was evidence that iris sepal length was significantly different between Western and Eastern states in the US $(t(147) = 14.09, p < .001, \\text{two-sided})$, and this difference was estimated to be 1.26cm. We are 95\\% confident that an Iris grown in an Eastern state, on average, would be between 1.08cm and 1.43cm longer than those grown in a Western state $(CI_{95}[1.08, 1.43])$.\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Model Predicted Values & Residuals\n\nModel predicted values are the estimates generated by a regression model for the dependent variable based on the independent variable(s), whilst residuals are the differences between these predicted values and the actual observed values (in turn indicating the accuracy of the model's predictions).\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-54' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-54', 'opt-start-54')\"> <span class=\"olab\">Predicted Values</span></span></div><div class=\"optional-body\" id = \"opt-body-54\" style=\"display: none;\">\n\n\n\n### Model predicted values ($\\hat y_i$) for sample data\n\nWe can get out the model predicted values for $y$, the \"y hats\" ($\\hat y$), for the data in the sample using various functions:\n\n- `predict(<fitted model>)`\n- `fitted(<fitted model>)`\n- `fitted.values(<fitted model>)`\n- `mdl$fitted.values`\n\nFor example, this will give us the estimated recall accuracy (point on our regression line) for each observed value of age for each of our 20 participants.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npredict(recall_simp)\n```\n:::\n\n\nFor space saving purposes (i.e., we don't need to see all 20 values for this demonstration!), we can return the first six predicted values via `head()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(predict(recall_simp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       1        2        3        4        5        6 \n62.23045 73.42542 69.49205 68.28179 70.09719 71.61002 \n```\n:::\n:::\n\n\n### Model predicted values for other (unobserved) data\n\nTo compute the model-predicted values for unobserved data (i.e., data not contained in the sample), we can use the following function:\n\n- `predict(<fitted model>, newdata = <dataframe>)`\n\nFor this example, we first need to remember that the model predicts `recall_accuracy` using the independent variable `age`. Hence, if we want predictions for new (unobserved) data, we first need to create a tibble with a column called `age` containing the age of individuals for which we want the prediction, and store this as a dataframe.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#Create dataframe 'newdata' containing the age values of 19, 32, and 99\nnewdata <- tibble(age = c(19,32,99))\nnewdata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 1\n    age\n  <dbl>\n1    19\n2    32\n3    99\n```\n:::\n:::\n\n\nThen we take `newdata` and add a new column called `accuracy_hat`, computed as the prediction from the fitted `recall_simp` using the `newdata` above:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnewdata <- newdata |>\n  mutate(\n    accuracy_hat = predict(recall_simp, newdata = newdata)\n  )\nnewdata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    age accuracy_hat\n  <dbl>        <dbl>\n1    19         78.3\n2    32         74.3\n3    99         54.1\n```\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-55' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-55', 'opt-start-55')\"> <span class=\"olab\">Residuals</span></span></div><div class=\"optional-body\" id = \"opt-body-55\" style=\"display: none;\">\n\n\n\nThe residuals ($\\hat \\epsilon_i$) represent the deviations between the actual responses and the predicted responses and can be obtained either as\n\n- `mdl$residuals`\n- `resid(mdl)`\n- `residuals(mdl)`\n- computing them as the difference between the response ($y_i$) and the predicted response ($\\hat y_i$)\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-56' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-56', 'opt-start-56')\"> <span class=\"olab\">Predicted Values - Example</span></span></div><div class=\"optional-body\" id = \"opt-body-56\" style=\"display: none;\">\n\n\n\nLets estimate (or predict) recall accuracy of two individuals with the following ages (a) 18, and (b) 118. There are a few ways we can do this, but first, let's recall our fitted model:\n\n$$\n\\widehat{Recall~Accuracy} = 84.02 - 0.31 \\cdot \\text{Age}\n$$\n\n\nFrom here we can:\n\n::: {.panel-tabset}\n\n## Substitute in Values\n\n- The predicted average recall accuracy for individuals who are aged 18 is:\n<br />\n$84.02 - (0.31 * 18) = 78.44$\n<br />\n<br />\n- The predicted average recall accuracy for individuals who are aged 118 is:\n<br />\n$84.02 - (0.31 * 118) = 47.44$\n\n## Use the `predict()` Function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnewdata <- tibble(age = c(18, 118))\n\naccuracy_hat <- predict(recall_simp, newdata = newdata)\naccuracy_hat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       1        2 \n78.56906 48.31237 \n```\n:::\n:::\n\n\n:::\n\nWe can see that both approaches (manually substituting values into the regression equation or using the `predict()` function) both give us the same values (slightly different due to rounding). \n\nBut, be careful to not go too far off the range of the available data (I don't know many 118 year olds, do you?). If you do, you will extrapolate. This is very dangerous...\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Source: Randall Munroe, xkcd.com](https://imgs.xkcd.com/comics/extrapolating.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n\n# Data Transformations\n\nThere are many transformations we can do to a continuous variable, but the most common ones are centering and scaling. These transformations can help to aid interpretability of our statistical models.  \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-57' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-57', 'opt-start-57')\"> <span class=\"olab\">Centering</span></span></div><div class=\"optional-body\" id = \"opt-body-57\" style=\"display: none;\">\n\n\n\nCentering simply means moving the entire distribution to be centered on some new value. We achieve this by subtracting our desired center from each value of a variable. \n\nA common option is to mean center (i.e. to subtract the mean from each value). This makes our new values all relative to the mean. We can center a variable on other things, such as the minimum or maximum value of the scale we are using, or some judiciously chosen value of interest.\n\n:::blue\n\nIn **R**\n\n::: {.panel-tabset}\n\n## Manually mean center variable\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_name <- data_name |>\n  mutate(\n   mc_variable = variable - mean(variable)\n    )\n```\n:::\n\n\n## Add mean centered variable to data set via `scale()` function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_name <- data_name |>\n    mutate(\n   mc_variable = scale(variable, scale = FALSE)\n   )\n```\n:::\n\n\n## Use `scale()` function within `lm` argument\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel <- lm(scale(DV, scale = FALSE) ~ scale(IV, scale = FALSE), data = data_name)\n```\n:::\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-58' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-58', 'opt-start-58')\"> <span class=\"olab\">Scaling</span></span></div><div class=\"optional-body\" id = \"opt-body-58\" style=\"display: none;\">\n\n\n\nScaling changes the units of the variable, and we do this by dividing the observations by some value. E.g., moving from “36 months” to “3 years” involves multiplying (scaling) the value by 1/12.\n\nThe most common transformation that involves scaling is called **standardisation**. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-59' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-59', 'opt-start-59')\"> <span class=\"olab\">Standardisation</span></span></div><div class=\"optional-body\" id = \"opt-body-59\" style=\"display: none;\">\n\n\n\nThis involves subtracting the mean from each individual observation (i.e., calculating individual deviations) and then dividing by the standard deviation. So standardisation centers on the sample mean and scales by the sample standard deviation. \n\nRecall that a standardized variable has mean of 0 and standard deviation of 1. If **both** $x$ and $y$ are standardised, our model coefficients ($\\beta$'s) are standardised too.\n\n**$z$-score Formula for $x$:**\n\n$$\nz_{x_i} = \\frac{x_i - \\bar{x}}{s_x}\n$$\n\n**$z$-score Formula for $y$:**\n\n$$\nz_{y_i} = \\frac{y_i - \\bar{y}}{s_y}\n$$\n\n:::blue\n\nIn **R**\n\n::: {.panel-tabset}\n\n## Manually create z-scored variables and then use these in model\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_name <- data_name |>\n  mutate(\n   z_variable = (variable - mean(variable)) / sd(variable)\n    )\n```\n:::\n\n\n\n## Add scaled variable to data set via `scale()` function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata_name <- data_name |> \n    mutate(\n   z_variable = scale(variable)\n   )\n```\n:::\n\n\n\n## Use `scale()` function within `lm` argument\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel <- lm(scale(DV) ~ scale(IV), data = data_name)\n```\n:::\n\n\n:::\n\n:::\n\nWhen we standardise variables in a regression model, it means we can talk about all our coefficients in terms of “standard deviation units”. To the extent that it is possible to do so, this puts our coefficients on scales of the similar magnitude, making qualitative comparisons between the sizes of effects a little more easy.\n\nWe tend to refer to coefficients using standardised variables as (unsurprisingly), “standardised coefficients”\n\nThere are two main ways that people construct standardised coefficients. One of which standardises just the predictor, and the other of which standardises both predictor and outcome:\n\n\n| predictor    | outcome      | in lm                     | coefficient                       | interpretation                                   |\n| ------------ | ------------ | ------------------------- | --------------------------------- | ------------------------------------------------ |\n| standardised | raw          | `y ~ scale(x)`            | $\\beta = b \\cdot s_x$             | \"difference in Y for a 1 SD increase in X\"       |\n| standardised | standardised | `scale(y) ~ scale(x)`     | $\\beta = b \\cdot \\frac{s_x}{s_y}$ | \"difference in SD of Y for a 1 SD increase in X\" |\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Model Fit\n\n## Linear Models\n\nAssessing model fit involves examining metrics like the sum of squares to measure variability explained by the model, the $F$-ratio to evaluate the overall significance of the model by comparing explained variance to unexplained variance, and $R$-squared / Adjusted $R$-squared to quantify the proportion of variance in the dependent variable explained by the independent variable(s).\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-60' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-60', 'opt-start-60')\"> <span class=\"olab\">Sums of Squares</span></span></div><div class=\"optional-body\" id = \"opt-body-60\" style=\"display: none;\">\n\n\n\nTo quantify and assess a model’s utility in explaining variance in an outcome variable, we can split the total variability of that outcome variable into two terms: the variability explained by the model plus the variability left unexplained in the residuals.\n\nThe sum of squares measures the deviation or variation of data points away from the mean (i.e., how spread out are the numbers in a given dataset). We are trying to find the equation/function that best fits our data by varying the least from our data points. \n\n##### Total Sum of Squares\n\n**Formula**: \n\n$$\n\\text{SS}_\\text{Total} = \\sum_{i=1}^{n}(y_i - \\bar{y})^2\n$$\nCan also be derived from:\n\n$$\n\\text{SS}_\\text{Total} = \\text{SS}_\\text{Model} + \\text{SS}_\\text{Residual}\n$$\n\n**In words**: \n\nSquared distance of each data point from the mean of $y$.\n\n**Description**: \n\nHow much variation there is in the DV.\n\n**Example:**\n\nLet's apply to a straightforward example to try by-hand. Suppose you have a simple linear regression model (i.e., with only one IV) where you have the following data points:\n\n\n| Observed   $x_i$   | Observed   $y_i$   |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\nSteps:  \n  \n1. Calculate the mean of $y$ ($\\bar y$)  \n2. Calculate for each observation $y_i$  - $\\bar y$  \n3. Square each of the obtained $y_i$  - $\\bar y$ values  \n4. Sum squared values  \n\n*Step 1: Calculate the mean of $y_i$*\n\n$\\bar y = {\\frac{5+7+8+6+9}{5}} = 7$\n\n*Step 2 & 3: Calculate for each observation $y_i$ - $\\bar y$ & square values*\n\n\n| Observed   $y_i$    | $y_i$ -  $\\bar y$  | $(y_i -  \\bar y)^2$ |\n|--------------------|---------------------|-------------------------|\n|         5          |      5 - 7 = -2     |          $-2^2 = 4$     |\n|         7          |      7 - 7 = 0      |          $0^2 = 0$      |\n|         8          |      8 - 7 = 1      |          $1^2 = 1$      |\n|         6          |      6 - 7 = -1     |          $-1^2 = 1$     |\n|         9          |      9 - 7 = 2      |          $2^2 = 4$      |\n\n*Step 4: Calculate sum squared values*\n\n$\\text{SS}_\\text{Total} = 4 + 0 + 1 + 1 + 4 = 10$\n\n##### Residual Sum of Squares\n\n**Formula**: \n\n$$\n\\text{SS}_\\text{Residual} = \\sum_{i=1}^{n}(y_i - \\hat{y}_i)^2\n$$\n\n**In words**: \n\nSquared distance of each point from the predicted value.\n\n**Description**: \n\nHow much of the variation in the DV the model did not explain - a measure that captures the unexplained variation in your regression model. Lower residual sum of squares suggests that your model fits the data well, and higher suggests that the model poorly explains the data (in other words, the lower the value, the better the regression model). If the value was zero here, it would suggest the model fits perfectly with no error.\n\n**Example:**\n\nLet's apply to a straightforward example to try by-hand. Suppose you have a simple linear regression model (i.e., with only one IV) where you have the following data points:\n\n\n| Observed   $x_i$   | Observed  $y_i$    |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\n\nSteps:   \n  \n1. Calculate predicted values ($\\hat{y}_i$)     \n2. Calculate residuals (i.e., the difference between the observed value ($y_i$) and the predicted value ($\\hat{y}_i$) for each observation)  \n3. Square the residuals   \n4. Sum squared values  \n\n*Step 1: Calculate predicted values*\n\nUsing $\\hat{y}_i = \\beta_0 + \\beta_1 \\cdot x_i$ and our model coefficients $\\beta_0 = 4.9$ and $\\beta_1 = 0.7$:\n\n\n| Observed  $x_i$    | Observed   $y_i$   | Predicted ($\\hat{y}_i$)   |\n|--------------------|--------------------|---------------------------|\n|         1          |           5        |  $4.9 + (0.7*1) = 5.6$    |\n|         2          |           7        |  $4.9 + (0.7*2) = 6.3$    |\n|         3          |           8        |  $4.9 + (0.7*3) = 7$      |\n|         4          |           6        |  $4.9 + (0.7*4) = 7.7$    |\n|         5          |           9        |  $4.9 + (0.7*5) = 8.4$    |\n\n\n*Step 2: Calculate residuals*\n\n+ $\\epsilon_1 = 5 − 5.6 = -0.6$\n+ $\\epsilon_2 = 7 - 6.3 = 0.7$\n+ $\\epsilon_3 = 8 - 7 = 1$\n+ $\\epsilon_4 = 6 - 7.7 = -1.7$\n+ $\\epsilon_5 = 9 − 8.4 = 0.6$\n\n*Step 3: Square the residuals*\n\n+ $\\epsilon_1^2 = -0.6^2 = 0.36$\n+ $\\epsilon_2^2 = 0.7^2 = 0.49$\n+ $\\epsilon_3^2 = 1^2 = 1$\n+ $\\epsilon_4^2 = -1.7^2 = 2.89$\n+ $\\epsilon_5^2 = 0.6^2 = 0.36$\n\n*Step 4: Calculate sum of squared values*\n\n$\\text{SS}_\\text{Residual} = 0.36 + 0.49 + 1 + 2.89 + 0.36 = 5.1$\n\n\n##### Model Sum of Squares\n\n**Formula**: \n\n$$\n\\text{SS}_\\text{Model} = \\sum_{i=1}^{n}(\\hat{y}_i - \\bar{y})^2\n$$\n\nCan also be derived from:\n\n$$\n\\text{SS}_\\text{Model} = \\text{SS}_\\text{Total} - \\text{SS}_\\text{Residual}\n$$\n\n**In words**: \n\nThe deviance of the predicted scores from the mean of $y$.\n\n**Description**: \n\nHow much of the variation in the DV your model explained - like a measure that captures how well the regression line fits your data.\n\n**Example:**\n\nLet's apply to a straightforward example to try by-hand. Suppose you have a simple linear regression model (i.e., with only one IV) where you have the following data points:\n\n\n| Observed   $x_i$   | Observed   $y_i$   |\n|--------------------|--------------------|\n|         1          |           5        |\n|         2          |           7        |\n|         3          |           8        |\n|         4          |           6        |\n|         5          |           9        |\n\n\nSteps:     \n  \n1. Calculate mean of $y$ ($\\bar y$)   \n2. Calculate predicted values ($\\hat{y}_i$)   \n3. Calculate for each observation $\\hat{y}_i  - \\bar y$    \n4. Squaring each of the obtained $\\hat{y}_i  - \\bar y$ values     \n5. Sum squared values   \n\n*Step 1: Calculate the mean of $y_i$ *\n\n$\\bar y = {\\frac{5+7+8+6+9}{5}} = 7$\n\n*Step 2: Calculate predicted values*\n\nUsing $\\hat{y}_i = \\beta_0 + \\beta_1 \\cdot x_i$ and our model coefficients $\\beta_0 = 4.9$ and $\\beta_1 = 0.7$:\n\n\n| Observed  ($x_i$)  | Observed  ($y_i$)  | Predicted ($\\hat{y}_i$)   |\n|--------------------|--------------------|---------------------------|\n|         1          |           5        |  $4.9 + (0.7*1) = 5.6$    |\n|         2          |           7        |  $4.9 + (0.7*2) = 6.3$    |\n|         3          |           8        |  $4.9 + (0.7*3) = 7$      |\n|         4          |           6        |  $4.9 + (0.7*4) = 7.7$    |\n|         5          |           9        |  $4.9 + (0.7*5) = 8.4$    |\n\n\n*Step 3 & 4: Calculate for each observation $\\hat{y}_i$  - $\\bar y$  & square values*\n\n\n| $\\hat{y}_i$  - $\\bar y$  | $(\\hat{y}_i  - \\bar y)^2$       |\n|--------------------------|---------------------------------|\n|    $5.6 - 7 = -1.4$      |      $(-1.4)^2 = 1.96$          |\n|    $6.3 - 7 = -0.7$      |      $(-0.7)^2 = 0.49$          |\n|    $7 - 7 = 0$           |      $(0)^2 = 0$                |\n|    $7.7 - 7 = 0.7$       |      $(0.7)^2 = 0.49$           |        \n|    $8.4 - 7 = 1.4$       |      $(1.4)^2 = 1.96$           |       \n\n\n*Step 5: Calculate sum of squared values*\n\n$\\text{SS}_\\text{Model} = 1.96 + 0.49 + 0 + 0.49 + 1.96 = 4.9$\n\n\n*Alternatively:*\n\n$$\n\\begin{align}\n& \\text{SS}_\\text{Model} = \\text{SS}_\\text{Total} - \\text{SS}_\\text{Residual} \\\\ \n& \\text{SS}_\\text{Model} = 10 - 5.1 \\\\  \n& \\text{SS}_\\text{Model} = 4.9 \\\\  \n\\end{align}\n$$\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-61' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-61', 'opt-start-61')\"> <span class=\"olab\">F-ratio</span></span></div><div class=\"optional-body\" id = \"opt-body-61\" style=\"display: none;\">\n\n\n\n**Overview:**\n\nWe can perform a test to investigate if a model is ‘useful’ — that is, a test to see if our explanatory variable explains more variance in our outcome than we would expect by just some random chance variable.  \n\nWith one predictor, the $F$-statistic is used to test the null hypothesis that the regression slope for that predictor is zero:\n\n$$\nH_0: \\text{the model is ineffective, }b_1 = 0 \\\\  \n$$\n$$\nH_1 : \\text{the model is effective, }b_1  \\neq 0 \\\\  \n$$\n\nIn multiple regression, the logic is the same, but we are now testing against the null hypothesis that **all** regression slopes are zero. Our test is framed in terms of the following hypotheses:\n\n$$ \nH_0: \\text{the model is ineffective, }b_1,...., b_k = 0 \\\\    \n$$\n\n$$\nH_1 : \\text{the model is effective, }b_1,...., b_k  \\neq 0 \\\\  \n$$\n\nThe relevant test-statistic is the $F$-statistic, which uses “Mean Squares” (these are Sums of Squares divided by the relevant degrees of freedom). We then compare that against (you guessed it) an $F$-distribution! $F$-distributions vary according to two parameters, which are both degrees of freedom.\n\n**Formula:** \n\n$$\n\\text{F}_{(df_{model},~df_{residual})} = \\frac{\\text{MS}_\\text{Model}}{\\text{MS}_\\text{Residual}} = \\frac{\\text{SS}_\\text{Model}/\\text{df}_\\text{Model}}{\\text{SS}_\\text{Residual}/\\text{df}_\\text{Residual}} \\\\\n\\quad \\\\\n$$\n\n$$\n\\begin{align}\n& \\text{Where:} \\\\\n& df_{model} = k \\\\\n& df_{residual} = n-k-1 \\\\\n& n = \\text{sample size} \\\\\n& k  = \\text{number of explanatory variables} \\\\\n\\end{align}\n$$\n\n\n**Description:**\n\nTo test the significance of an overall model, we can conduct an $F$-test. The $F$-test compares your model to a model containing zero predictor variables (i.e., the intercept only model), and tests whether your added predictor variables significantly improved the model.\n\nIt is called the $F$-ratio because it is the ratio of the how much of the variation is explained by the model (per parameter) versus how much of the variation is unexplained (per remaining degrees of freedom). \n\nThe $F$-test involves testing the statistical significance of the $F$-ratio.   \n\n**Q:** What does the $F$-ratio test?  \n**A:** The null hypothesis that all regression slopes in a model are zero (i.e., explain no variance in your outcome/DV). The alternative hypothesis is that **at least one of the slopes is not zero**. \n\n\nThe $F$-ratio you see at the bottom of `summary(model)` is actually a comparison between two models: your model (with some explanatory variables in predicting $y$) and the *null model*. \n\nIn regression, the null model can be thought of as the model in which all explanatory variables have zero regression coefficients. It is also referred to as the __intercept-only model__, because if all predictor variable coefficients are zero, then we are only estimating $y$ via an intercept (which will be the mean - $\\bar y$). \n\n**Interpretation:** \n\nAlongside viewing the $F$-ratio, you can see the results from testing the null hypothesis that all of the coefficients are $0$ (the alternative hypothesis is that at least one coefficient is $\\neq 0$. Under the null hypothesis that all coefficients = 0, the ratio of explained:unexplained variance should be approximately 1)\n\nIf your model predictors do explain some variance, the $F$-ratio will be significant, and you would reject the null, as this would suggest that your predictor variables included in your model improved the model fit (in comparison to the intercept only model).\n\n\n*Points to note:*\n\n- The larger your $F$-ratio, the better your model\n- The $F$-ratio will be close to 1 when the null is true (i.e., that all slopes are zero)\n\n\n\n**How to calculate $F$-ratio**\n\n::: {.panel-tabset}\n\n### By Hand\n\nSteps:     \n  \n1. Calculate model sum of squares \n2. Calculate residual sum of squares \n3. Calculate total sum of squares \n4. Calculate $df_{model}$   \n5. Calculate $df_{residual}$   \n\n  \n*Step 1, 2, & 3*\n  \nFollow steps above in the Sums of Squares flashcard:\n\n$$\n\\begin{align}\n& \\text{SS}_\\text{Total} = 10  \\\\ \n& \\text{SS}_\\text{Residual} = 5.1 \\\\  \n& \\text{SS}_\\text{Model} = 4.9 \\\\  \n\\end{align}\n$$\n  \n*Step 4: Calculate $df_{model}$*\n\n$$\n\\begin{align}\n&df_{model} = k  \\\\  \n&df_{model} = 1 \n\\end{align}\n$$\n\n*Step 5: Calculate $df_{residual}$*\n\n$$\n\\begin{align}\n&df_{residual} = n-k-1   \\\\  \n&df_{residual} = 5-1-1  \\\\  \n&df_{residual} = 3  \n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n&\\text{F}_{(df_{model},~df_{residual})} = \\frac{\\text{MS}_\\text{Model}}{\\text{MS}_\\text{Residual}} = \\frac{\\text{SS}_\\text{Model}/\\text{df}_\\text{Model}}{\\text{SS}_\\text{Residual}/\\text{df}_\\text{Residual}} \\\\  \n\\\\  \n&\\text{F}_{(df_{model},~df_{residual})} = \\frac{4.9/1}{5.1/3} \\\\  \n\\\\  \n&\\text{F}_{(df_{model},~df_{residual})} = \\frac{4.9}{1.7} \\\\  \n\\\\  \n&\\text{F}_{(df_{model},~df_{residual})} = 2.88  \n\\end{align}\n$$\n\n### Using R\n:::blue\n\nIn **R**\n\nWe can see the $F$-statistic and associated $p$-value at the bottom of the output of `summary(<modelname>)`:\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, F statistic highlighted](images/recall_mdl_output_f_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\n\nAlternatively, you can extract this information as it is stored in the `summary()` of the model:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#F-Statistic\nsummary(recall_multi)$fstatistic\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   value    numdf    dendf \n12.92426  2.00000 17.00000 \n```\n:::\n\n```{.r .cell-code}\n#P-Value\npf(summary(recall_multi)$fstatistic[1], \n   summary(recall_multi)$fstatistic[2], \n   summary(recall_multi)$fstatistic[3], \n   lower.tail = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       value \n0.0003866881 \n```\n:::\n:::\n\n\n:::\n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nThe linear model with recall confidence and age explained a significant amount of variance in recall accuracy beyond what we would expect by chance $F(2, 17) = 12.92, p < .001$. \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-62' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-62', 'opt-start-62')\"> <span class=\"olab\">R-squared and Adjusted R-squared</span></span></div><div class=\"optional-body\" id = \"opt-body-62\" style=\"display: none;\">\n\n\n\n**Overview:**\n\n$R^2$ represents the proportion of variance in $Y$ that is explained by the model predictor variables. \n\n**Formula:**\n\nThe $R^2$ coefficient is defined as the proportion of the total variability in the outcome variable which is explained by our model:\n  \n$$\nR^2 = \\frac{SS_{Model}}{SS_{Total}} = 1 - \\frac{SS_{Residual}}{SS_{Total}}\n$$\n\nThe Adjusted $R^2$ coefficient is defined as:\n  \n$$\n\\hat R^2 = 1 - \\frac{(1 - R^2)(n-1)}{n-k-1}\n\\quad \\\\\n$$\n\n$$\n\\begin{align}\n& \\text{Where:} \\\\\n& n = \\text{sample size} \\\\\n& k = \\text{number of explanatory variables} \\\\\n\\end{align}\n$$\n\n<br>\n\n**When to report Multiple $R^2$ vs. Adjusted $R^2$:**\n\nThe Multiple $R^2$ value should be reported for a simple linear regression model (i.e., one predictor).   \n\nUnlike $R^2$, Adjusted-$R^2$ does not necessarily increase with the addition of more explanatory variables, by the inclusion of a penalty according to the number of explanatory variables in the model. Since Adjusted-$R^2$ is adjusted for the number of predictors in the model, this should be used when there are 2 or more predictors in the model. As a side note, the Adjusted-$R^2$ should always be less than or equal to $R^2$.\n\n\n**How to calculate Multiple $R^2$ & Adjusted $R^2$**\n\n::: {.panel-tabset}\n\n### By Hand\n\nUsing the information calculated above in the Sums of Squares flashcard above, we can simply substitute values into the formula for $R^2$:\n\n$$\n\\begin{align}  \n& R^2 = \\frac{\\text{SS}_{\\text{Model}}}{\\text{SS}_{\\text{Total}}} = 1 - \\frac{\\text{SS}_{\\text{Residual}}}{\\text{SS}_{\\text{Total}}} \\\\\n\\\\  \n& R^2 = \\frac{4.9}{10} = 1 - \\frac{5.1}{10} \\\\  \n\\\\  \n& R^2 = 0.49 = 0.49\n\\end{align}  \n$$\n\nAnd for Adjusted-$R^2$:\n\n$$\n\\begin{align}  \n& \\text{Adjusted-R}^2 = 1 - \\frac{(1 - R^2)(n-1)}{n-k-1} \\\\\n& \\quad \\\\  \n& \\text{Adjusted-R}^2 = 1 - \\frac{(1 - 0.49)(5-1)}{5-1-1} \\\\\n& \\quad \\\\  \n& \\text{Adjusted-R}^2 = 1 - \\frac{(0.51)(4)}{3} \\\\  \n& \\quad \\\\  \n& \\text{Adjusted-R}^2 = 1 - \\frac{2.04}{3} \\\\\n& \\quad \\\\  \n& \\text{Adjusted-R}^2 = 1 - 0.68 \\\\\n& \\quad \\\\  \n& \\text{Adjusted-R}^2 = 0.32 \\\\\n\\end{align} \n$$\n  \n### Using R\n  \n:::blue\n\nIn **R**\n\nWe can see both $R^2$ and Adjusted-$R^2$ in the second bottom row of the `summary(<modelname>)`:\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Multiple regression output in R, R^2 statistic highlighted](images/recall_mdl_output_r_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n  \n  \nAlternatively, you can extract this information as it is stored in the `summary()` of the model:\n  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#R-Squared\nsummary(recall_multi)$r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6032536\n```\n:::\n\n```{.r .cell-code}\n#Adjusted R-Squared\nsummary(recall_multi)$adj.r.squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5565775\n```\n:::\n:::\n\n\n:::\n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nTogether, recall confidence and age explained approximately 55.66% of the variance in recall accuracy. \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Model Comparisons\n\n## Linear Models\n\nOne useful thing we might want to do is compare our models with and without some predictor(s).There are numerous ways we can do this, but the method chosen depends on the models and underlying data:\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![](images/comparisons_chart.png){fig-align='left' width=100%}\n:::\n:::\n\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-63' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-63', 'opt-start-63')\"> <span class=\"olab\">Nested vs Non-Nested Models</span></span></div><div class=\"optional-body\" id = \"opt-body-63\" style=\"display: none;\">\n\n\n\n**Nested Models**\n\nConsider that you have two regression models where Model 1 contains a subset of the predictors contained in the other Model 2 and is fitted to the same data. More simply, Model 2 contains all of the predictors included in Model 1, **plus** additional predictor(s). This means that Model 1 is *nested* within Model 2, or that Model 1 is a *submodel* of Model 2. These two terms, at least in this setting, are interchangeable - it might be easier to think of Model 1 as your null and Model 2 as your alternative.\n\n**Non-Nested Models**\n\nConsider that you have two regression models where Model 1 contains different variables to those contained in Model 2, where both models are fitted to the same data. More simply, Model 1 and Model 2 contain unique variables that are not shared. This means that Model 1 and Model 2 are **not** nested.\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-64' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-64', 'opt-start-64')\"> <span class=\"olab\">Incremental F-test</span></span></div><div class=\"optional-body\" id = \"opt-body-64\" style=\"display: none;\">\n\n\n\nIf (*and only if*) two models are __nested__, can we compare them using an __incremental F-test__.  \n\nThis is a formal test of whether the additional predictors provide a better fitting model.  \nFormally this is the test of:  \n\n+ $H_0:$ coefficients for the added/omitted variables are all zero.\n\n+ $H_1:$ at least one of the added/omitted variables has a coefficient that is not zero. \n\nThe $F$-ratio for comparing the residual sums of squares between two models can be calculated as:\n\n$$\nF_{(df_R-df_F),~df_F} = \\frac{(SSR_R-SSR_F)/(df_R-df_F)}{SSR_F / df_F} \\\\\n\\quad \\\\\n$$\n$$\n\\begin{align}\n& \\text{Where:} \\\\\n\\\\\n& SSR_R = \\text{residual sums of squares for the restricted model} \\\\\n& SSR_F = \\text{residual sums of squares for the full model} \\\\\n& df_R = \\text{residual degrees of freedom from the restricted model} \\\\\n& df_F = \\text{residual degrees of freedom from the full model} \\\\\n\\end{align}\n$$\n\n:::blue\n**In R**\n\nWe can conduct an incremental $F$-test to compare two models by fitting both models using `lm()`, and passing them to the `anova()` function:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel1 <- lm( ... )\nmodel2 <- lm( ... )\nanova(model1, model2)\n```\n:::\n\n\nIf we wanted to, for example, compare a model with just one predictor, $x1$, to a model with 2 predictors: $x1$, and $x2$, we can assess the extent to which the variable $x2$ improves model fit:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmodel1 <- lm(y ~ x1, data = data_name)\nmodel2 <- lm(y ~ x1 + x2, data = data_name)\nanova(model1, model2)\n```\n:::\n\n  \n    \nFor example:\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Model Comparisons using Incremental F-test](images/recall_mdl_anova_comp2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nRecall confidence explained a significant amount of variance in recall accuracy beyond age $(F(1, 17) = 21.95, p < .001)$. \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br>\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-65' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-65', 'opt-start-65')\"> <span class=\"olab\">AIC & BIC</span></span></div><div class=\"optional-body\" id = \"opt-body-65\" style=\"display: none;\">\n\n\n\nAIC (Akaike Information Criterion) and BIC (Bayesian Information Criterion) combine information about the sample size, the number of model parameters, and the residual sums of squares ($SS_{residual}$). Models do not *need* to be nested to be compared via AIC and BIC, __but__ they need to have been fit to the same dataset.    \n\nAIC can be calculated as:  \n  \n$$\n\\begin{align}\n& AIC = n\\,\\text{ln}\\left( \\frac{SS_{residual}}{n} \\right) + 2k \\\\\n\\end{align}\n\\quad \\\\\n$$\n\n\nBIC can be calculated as:   \n  \n$$\n\\begin{align}\n& BIC = n\\,\\text{ln}\\left( \\frac{SS_{residual}}{n} \\right) + k\\,\\text{ln}(n) \\\\\n\\end{align}\n\\quad \\\\\n$$\n  \nWhere for both AIC and BIC:  \n  \n$$\n\\begin{align}\n& SS_{residual} = \\text{sum of squares residuals} \\\\\n& n = \\text{sample size} \\\\\n& k = \\text{number of explanatory variables} \\\\\n& \\text{ln} = \\text{natural log function} \n\\end{align}\n$$\n  \n   \nFor both of these fit indices, lower values are better, and both include a penalty for the number of predictors in the model (although BIC's penalty is harsher). \n\nSo how do we determine whether there is a statistical difference between two models? To evaluate our model comparisons, we need to look at the difference ($\\Delta$) between the two values:  \n  \n+ **AIC**: There are no specific thresholds to suggest how big a difference in two models is needed to conclude that one is substantively better than the other  \n    \n    \n+ **BIC**: Using the following $\\Delta BIC$ cutoffs (Raftery, 1995):\n\n  \n| Value             | Interpretation of Difference between Models  |\n|-------------------|----------------------------------------------|\n| $\\Delta < 2$      | No evidence                                  |\n| $2 > \\Delta < 6$  | Positive evidence                            |\n| $6 > \\Delta < 10$ | Strong evidence                              |\n| $\\Delta > 10$     | Very strong evidence                         |\n\n\n:::blue\n**In R**\n\nWe can calculate AIC and BIC by using the `AIC()` and `BIC()` functions respectively:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#AIC\nAIC(modelname)\n\n#BIC\nBIC(modelname)\n```\n:::\n\n  \n  \nFor example, with AIC:  \n  \n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Model Comparisons using AIC](images/recall_mdl_aic_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n  \nand BIC:\n  \n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![Model Comparisons using BIC](images/recall_mdl_bic_2526.png){fig-align='left' width=80%}\n:::\n:::\n\n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\n**Example Interpretation**\n\nBased on both AIC and BIC, the model predicting recall accuracy that included both recall confidence and age was better fitting $(\\text{AIC} = 152.28; \\text{BIC} = 156.27)$ than the model with age alone $(\\text{AIC} = 166.86; \\text{BIC} = 169.85)$. \n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Model Assumptions\n\n## Linear Models\n\nLinear models rely on numerous underlying assumptions about the data. These assumptions ensure that the association between variables is appropriately captured, and that inferences drawn from the model are accurate and valid. Model diagnostics can help further assess whether these assumptions hold. When these assumptions are violated, there are numerous techniques that can be employed, such as through data transformations or using robust alternatives, to ensure reliable model interpretations.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-66' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-66', 'opt-start-66')\"> <span class=\"olab\">Linearity</span></span></div><div class=\"optional-body\" id = \"opt-body-66\" style=\"display: none;\">\n\n\n\n### Simple Linear Regression\nIn simple linear regression with only one explanatory variable, we could assess linearity through a simple scatterplot of the outcome variable against the explanatory. This would allow us to check if the errors have a mean of zero. If this assumption was met, the residuals would appear to be randomly scattered around zero.  \n  \nThe rationale for this is that, once you remove from the data the linear trend, what's left over in the residuals should not have any trend, i.e. have a mean of zero.\n\n### Multiple Regression\nIn multiple regression, however, it becomes more necessary to rely on diagnostic plots of the model residuals. This is because we need to know whether the relations are linear between the outcome and each predictor _after accounting for the other predictors in the model._   \n\nIn order to assess this, we use **partial-residual plots** (also known as 'component-residual plots'). This is a plot with each explanatory variable $x_j$ on the x-axis, and **partial residuals** on the y-axis***.\n\nPartial residuals for a predictor $x_j$ are calculated as:\n$$\n\\hat \\epsilon + \\hat \\beta_j x_j\n$$\n\n:::blue\n\nIn **R**\n\n::: {.panel-tabset}\n\n### Simple Linear Regression\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#specify model\nrecall_simp <- lm(recall_accuracy ~ age, data = recalldata)\n\n#create plot\nggplot(recalldata, aes(x = age, y = recall_accuracy)) + \n    geom_point() + \n    geom_smooth(method = \"lm\", se = FALSE, colour = \"blue\") + #fit straight line to data\n    geom_smooth(method = \"loess\", se = FALSE, colour = \"red\") + #fit loess line to data\n    labs(x = \"Age\", y = \"Recall Accuracy\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-104-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\nThe loess line should closely follow the data.\n\n:::\n\n### Multiple Linear Regression\n\nWe can create these plots for all predictors in the model by using the `crPlots()` function from the **car** package:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#specify model\nrecall_mdl <- lm(recall_accuracy ~ recall_confidence + age, data = recalldata)\n\n#create plots\ncrPlots(recall_mdl)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-105-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\nYou are looking for the pink line to follow a linear trend line (i.e., follow the blue line). In other words, the loess line should closely follow the linear line. \n\n:::\n\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-67' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-67', 'opt-start-67')\"> <span class=\"olab\">Independence (of errors)</span></span></div><div class=\"optional-body\" id = \"opt-body-67\" style=\"display: none;\">\n\n\n\nThe 'independence of errors' assumption is the condition that the errors do not have some underlying relationship which is causing them to influence one another. \n<br>\n\nThere are many sources of possible dependence, and often these are issues of study design. For example, we may have groups of observations in our data which we would expect to be related (e.g., multiple trials from the same participant). Our modelling strategy would need to take this into account.\n<br>\n\nOne form of dependence is **autocorrelation** - this is when observations influence those adjacent to them. It is common in data for which *time* is a variable of interest (e.g, the humidity today is dependent upon the rainfall yesterday). \n\nTesting for the independence of errors can be pretty difficult, unless you know the potential source of correlation between cases (more on this in DAPR3!). \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-68' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-68', 'opt-start-68')\"> <span class=\"olab\">Normality (of errors)</span></span></div><div class=\"optional-body\" id = \"opt-body-68\" style=\"display: none;\">\n\n\n\nThe normality assumption is the condition that the errors $\\epsilon$ are normally distributed in the population.  \n\nWe can visually assess this condition through histograms, density plots, and quantile-quantile plots (QQplots) of our residuals $\\hat \\epsilon$.  \n\n::: {.panel-tabset}\n\n### Histogram\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(recall_mdl$residuals)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-106-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n\n### QQPlot\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(recall_mdl, which = 2)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-107-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\nRemember that departures from a linear trend in QQ plots indicate a lack of normality.\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-69' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-69', 'opt-start-69')\"> <span class=\"olab\">Equal Variances (Homoscedasticity)</span></span></div><div class=\"optional-body\" id = \"opt-body-69\" style=\"display: none;\">\n\n\n\nThe equal variances assumption is that the error variance $\\sigma^2$ is constant across values of the predictor(s) $x_1, \\dots,  x_k$, and across values of the fitted values $\\hat y$. This sometimes gets termed \"Constant\" vs \"Non-constant\" variance. This is presented visually in @fig-ncv-violate and @fig-ncv-noviolate. \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Non-constant variance for numeric and categorical X](1_b2_reading_files/figure-html/fig-ncv-violate-1.png){#fig-ncv-violate fig-align='center' width=90%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Constant variance for numeric and categorical X](1_b2_reading_files/figure-html/fig-ncv-noviolate-1.png){#fig-ncv-noviolate fig-align='center' width=90%}\n:::\n:::\n\n\n:::blue\n\nIn **R**\n\nWe can create plots of the _Pearson residuals_ against the predicted values $\\hat y$ and against the predictors $x_1$, ... $x_k$ by using the `residualPlots()` function from the **car** package. This function also provides the results of a lack-of-fit test for each of these relationships (note when it is the fitted values $\\hat y$ it gets called \"Tukey's test\"). \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(car)\nresidualPlots(recall_mdl)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-110-1.png){fig-align='center' width=80%}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n                  Test stat Pr(>|Test stat|)\nrecall_confidence    1.4473           0.1671\nage                 -0.0474           0.9627\nTukey test           0.8769           0.3805\n```\n:::\n:::\n\n\nAlternatively, we can use:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(recall_mdl, which = 1)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-111-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\nIf the assumption is met, you should see a random scatter of $(x,y)$ points with constant mean and variance functions i.e., the vertical spread of the residuals should roughly be the same everywhere.\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-70' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-70', 'opt-start-70')\"> <span class=\"olab\">Useful Assumption Plots</span></span></div><div class=\"optional-body\" id = \"opt-body-70\" style=\"display: none;\">\n\n\n\n::: {.panel-tabset}\n\n### `plot(modelname)`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nWe can run `plot(mymodel)` which will cycle through these plots (asking us to press enter each time to move to the next plot), or we can arrange these plots in a matrix via `par(mfrow)`, for example in a 2 x 2 matrix as shown below (make sure to always reset your graphical parameters! If needed, we could also extract specific plots using, for instance: `plot(mymodel, which = 3)` for the third plot.\n\n:::blue\n**In R**\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\nplot(recall_mdl)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-113-1.png){fig-align='center' width=80%}\n:::\n\n```{.r .cell-code}\npar(mfrow=c(1,1))\n```\n:::\n\n\n:::\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\n\n- Top Left: For the __Residuals vs Fitted__ plot, we want the red line to be horizontal at close to zero across the plot. We don't want the residuals (the points) to be fanning in/out.  \n- Top Right: For the __Normal Q-Q__ plot, we want the residuals (the points) to follow closely to the diagonal line, indicating that they are relatively normally distributed.^[QQplots plot the values against the associated percentiles of the normal distribution. So if we had ten values, it would order them lowest to highest, then plot them on the y against the 10th, 20th, 30th.. and so on percentiles of the standard normal distribution (mean 0, SD 1)]\n- Bottom Left: For the __Scale-Location__ plot, we want the red line to be horizontal across the plot. These plots allow us to examine the extent to which the variance of the residuals changes across the fitted values. If it is angled, we are likely to see fanning in/out of the points in the residuals vs fitted plot.\n- Bottom Right: The __Residuals vs Leverage__ plot indicates points that might be of individual interest as they may be unduly influencing the model. There are funnel-shaped lines on this plot (sometimes out of scope of the plotting window). Ideally, we want our residuals inside the funnel - the further the residual is to the right (the more leverage it has), the closer to the 0 we want it to be.  \n\n*Note, if we have only categorical predictors in our model, many of these will show vertical lines of points. This doesn't indicate that anything is wrong, and the same principles described above continue to apply*\n\n:::\n\n### `check_model(modelname)`\n\nThe `check_model()` function from the **performance** package is a useful way to check the assumptions of models, as it also returns some useful notes to aid your interpretation. However, it is important to check each assumption individually with plots that are more suitable for a statistics report.\n\n:::blue\n**In R**\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(performance)\ncheck_model(recall_mdl)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-114-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-71' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-71', 'opt-start-71')\"> <span class=\"olab\">Multicollinearity</span></span></div><div class=\"optional-body\" id = \"opt-body-71\" style=\"display: none;\">\n\n\n\nFor the linear model with **multiple** explanatory variables, we need to also think about **multicollinearity** - this is when two (or more) of the predictors in our regression model are moderately or highly correlated.  \n\nWe can assess multicollinearity using the **variance inflation factor (VIF)**, which for a given predictor $x_j$ is calculated as:  \n\n$$\nVIF_j = \\frac{1}{1-R_j^2} \\\\\n$$\n\n:::frame\n\n[**Interpretation Guidance**]{style=\"color:red;\"}\n\nSuggested cut-offs for VIF are varied. Some suggest 10, others 5. Define what you will consider an acceptable value _prior_ to calculating it. You could loosely interpret VIF values $>5$ as moderate multicollinearity and values $>10$ as severe multicollinearity. \n\n:::\n\n:::blue\n\nIn **R**  \n  \nThe `vif()` function from the **car** package will provide VIF values for each predictor in your model. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvif(INSERT_MODEL_NAME)\n```\n:::\n\n\n\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-72' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-72', 'opt-start-72')\"> <span class=\"olab\">Individual Case Diagnostics</span></span></div><div class=\"optional-body\" id = \"opt-body-72\" style=\"display: none;\">\n\n\n\nWe have seen that some specific individual cases in our data can influence our model more than others. We can identify these as:\n\n+ **Regression outliers:** A large residual $\\hat \\epsilon_i$ - i.e., a big discrepancy between their predicted y-value and their observed y-value.  \n    + **Standardised residuals:** For residual $\\hat \\epsilon_i$, divide by the estimate of the standard deviation of the residuals. In R, the `rstandard()` function will give you these\n    + **Studentised residuals:** For residual $\\hat \\epsilon_i$, divide by the estimate of the standard deviation of the residuals excluding case $i$. In R, the `rstudent()` function will give you these.\n+ **High leverage cases:** These are cases which have considerable _potential_ to influence the regression model (e.g., cases with an unusual combination of predictor values). \n    + **Hat values:** are used to assess leverage. In R, The `hatvalues()` function will retrieve these. \n+ **High influence cases:** When a case has high leverage *and* is an outlier, it will have a large influence on the regression model. \n    + **Cook's Distance:** combines *leverage* (hatvalues) with *outlying-ness* to capture influence: $D_i = \\text{Outlyingness} \\times \\text{Leverage}$. Cook's distance refers to the average distance the $\\hat{y}$ values will move if a given case is removed. In `R`, the `cooks.distance()` function will provide these values. \nAlongside Cook's Distance, we can examine the extent to which model estimates and predictions are affected when an entire case is dropped from the dataset and the model is refitted.  \n+ **DFFit:** the change in the predicted value at the $i^{th}$ observation with and without the $i^{th}$ observation is included in the regression.  \n+ **DFbeta:**  the change in a specific coefficient with and without the $i^{th}$ observation is included in the regression.  DFbeta represents the difference in the beta coefficients when a case is excluded from the model versus when it’s included. A large DFbeta value would suggest that a case has a substantial impact on the estimated coefficients, and thus a high influence on the model results; a small DFbeta value would suggest that the case has less influence on the estimated coefficients. A commonly used cut-off or threshold to compare $|DFBETA|$ values (absolute values) against is $\\frac{2}{\\sqrt{n}}$ (see Belsley et al., (1980) p. 28 for more info)^[Belsley, D. A., Kuh, E., & Welsch, R. E. (2005). Regression diagnostics: Identifying influential data and sources of collinearity. John Wiley & Sons. DOI: 10.1002/0471725153]. \n+ **DFbetas:**  the change in a specific coefficient divided by the standard error, with and without the $i^{th}$ observation is included in the regression.  \n+ **COVRATIO:** measures the effect of an observation on the covariance matrix of the parameter estimates. In simpler terms, it captures an observation's influence on standard errors. Values which are $>1+\\frac{3(k+1)}{n}$ or $<1-\\frac{3(k+1)}{n}$ are considered as having strong influence. \n\n:::blue\n\nIn **R**, we can get lots of these measures with the `influence.measures()` function:\n\n\n+ `influence.measures(my_model)` will give you out a dataframe of the various measures.\n+ `summary(influence.measures(my_model))` will provide a nice summary of what R deems to be the influential points.\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-73' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-73', 'opt-start-73')\"> <span class=\"olab\">Next Steps: What to do with Violations of Assumptions / Problematic Case Diagnostic Results</span></span></div><div class=\"optional-body\" id = \"opt-body-73\" style=\"display: none;\">\n\n\n\nThere are lots of different options available, and there is no one right answer. Assuming that we have no issues with model specification (i.e., are not missing variables, have modeled appropriately), then we may want to consider one of the below approaches (note: this is **not** an exhaustive list!)\n\n::: {.panel-tabset}\n\n## Investigate Observations\n\nThe first step is to re-examine your data. It is important to be familiar with your dataset, as you need to know what values are typical, normal, and possible. Could it be the case that you have missed some impossible values (e.g., a negative value of a persons height), values outwith the possible range (e.g., a score of 55 on a survey where scores can only range 10-50), values that don't make any sense (e.g., an age of 200), or maybe there are even typos / data entry errors (e.g., forgetting to put a decimal point, so having a height of 152m instead of 1.52m)! \n\nIf there is a simple error in the data, it could be that you can fix the typo. If that is not possible (maybe you didn't collect the data, so are unsure of what the value(s) should/could be), you will need to delete the value (i.e., set as an `NA`), because you know that it is incorrect. \n\nWe should aim to never change a legitimate value where possible (and remember that if you have a large dataset, a small number of extreme values will be unlikely to have a strong influence on your results). \n\nIf there is an extreme, but legitimate value that you have determined is adversely influencing your model (i.e., by examining the assumptions and diagnostics as outlined above), you may want to consider ways to reduce this influence (e.g., **winsorizing** -  which essentially truncates or caps the identified extreme values to a specified percentile, in turn reducing their influence on the model without completely eliminating the observation(s). For example, you could replace values below the 5th percentile with the 5th percentile value, and values above the 95th percentile with the 95th percentile value).\n\nIf after re-examining your data you cannot identify any atypical, non-normal, or impossible values, you may need to select a different approach as outlined below. \n\n## Sensitivity Analysis\n\nThis allows us to assess the **sensitivity** of our results (i.e., parameter estimates, p-values, confidence intervals) to changes in our modelling approach (i.e., the removal of observations).\n\nWe can re-fit our model after excluding our identified outliers and potentially influential observations, and compare these results to the original model.\n\n::: {.callout-important icon=false collapse=true}\n\n# Process of Removing Observations\n\nThe current example involves removing all identified outliers and potentially influential observations at the same time. Ideally, and to ensure a more thorough sensitivity analysis, you would remove each of these observations one at a time, assess the effects on the model by comparing to your original, reassessing the remaining pre-identified observations, and repeating the process if necessary. \n\n:::\n\n::: {.panel-tabset}\n\n### Original Model\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## wellbeing model\nwb_mdl1 <- lm(wellbeing ~ outdoor_time + social_int, data = mwdata) \nsummary(wb_mdl1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = wellbeing ~ outdoor_time + social_int, data = mwdata)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.7611  -3.1308  -0.4213   3.3126  18.8406 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  28.62018    1.48786  19.236  < 2e-16 ***\noutdoor_time  0.19909    0.05060   3.935 0.000115 ***\nsocial_int    0.33488    0.08929   3.751 0.000232 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.065 on 197 degrees of freedom\nMultiple R-squared:  0.1265,\tAdjusted R-squared:  0.1176 \nF-statistic: 14.26 on 2 and 197 DF,  p-value: 1.644e-06\n```\n:::\n:::\n\n\n\n### Model with Observations Removed\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## wellbeing model\nwb_mdl2 <- lm(wellbeing ~ outdoor_time + social_int, data = mwdata[-c(16, 25, 50, 53, 56, 58, 59, 60, 62, 72, 73, 75, 76, 78, 79, 85, 101, 109, 125, 126, 127, 131, 149, 151, 159, 163, 165, 169, 173, 176, 179, 197), ])\nsummary(wb_mdl2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = wellbeing ~ outdoor_time + social_int, data = mwdata[-c(16, \n    25, 50, 53, 56, 58, 59, 60, 62, 72, 73, 75, 76, 78, 79, 85, \n    101, 109, 125, 126, 127, 131, 149, 151, 159, 163, 165, 169, \n    173, 176, 179, 197), ])\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-8.7700 -2.6445 -0.6073  2.8586  9.6605 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  27.91311    1.42612  19.573  < 2e-16 ***\noutdoor_time  0.19356    0.04901   3.950 0.000116 ***\nsocial_int    0.39830    0.08964   4.443 1.62e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.044 on 165 degrees of freedom\nMultiple R-squared:  0.1774,\tAdjusted R-squared:  0.1675 \nF-statistic:  17.8 on 2 and 165 DF,  p-value: 1.004e-07\n```\n:::\n:::\n\n\n\n### Compare `summary()` output\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntab_model(wb_mdl1, wb_mdl2,\n          dv.labels = c(\"Wellbeing (WEMWBS Scores)\", \"Wellbeing (WEMWBS Scores)\"),\n          pred.labels = c(\"outdoor_time\" = \"Outdoor Time (hours per week)\",\n                          \"social_int\" = \"Social Interactions (number per week)\"),\n          title = \"Regression Table for Wellbeing Models wb1 and wb2\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table style=\"border-collapse:collapse; border:none;\">\n<caption style=\"font-weight: bold; text-align:left;\">Regression Table for Wellbeing Models wb1 and wb2</caption>\n<tr>\n<th style=\"border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm;  text-align:left; \">&nbsp;</th>\n<th colspan=\"3\" style=\"border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; \">Wellbeing (WEMWBS Scores)</th>\n<th colspan=\"3\" style=\"border-top: double; text-align:center; font-style:normal; font-weight:bold; padding:0.2cm; \">Wellbeing (WEMWBS Scores)</th>\n</tr>\n<tr>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  text-align:left; \">Predictors</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">Estimates</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">CI</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">p</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">Estimates</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  \">CI</td>\n<td style=\" text-align:center; border-bottom:1px solid; font-style:italic; font-weight:normal;  col7\">p</td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; \">(Intercept)</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">28.62</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">25.69&nbsp;&ndash;&nbsp;31.55</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \"><strong>&lt;0.001</strong></td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">27.91</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">25.10&nbsp;&ndash;&nbsp;30.73</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  col7\"><strong>&lt;0.001</strong></td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; \">Outdoor Time (hours per<br>week)</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.20</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.10&nbsp;&ndash;&nbsp;0.30</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \"><strong>&lt;0.001</strong></td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.19</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.10&nbsp;&ndash;&nbsp;0.29</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  col7\"><strong>&lt;0.001</strong></td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; \">Social Interactions<br>(number per week)</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.33</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.16&nbsp;&ndash;&nbsp;0.51</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \"><strong>&lt;0.001</strong></td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.40</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  \">0.22&nbsp;&ndash;&nbsp;0.58</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:center;  col7\"><strong>&lt;0.001</strong></td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm; border-top:1px solid;\">Observations</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left; border-top:1px solid;\" colspan=\"3\">200</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left; border-top:1px solid;\" colspan=\"3\">168</td>\n</tr>\n<tr>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; text-align:left; padding-top:0.1cm; padding-bottom:0.1cm;\">R<sup>2</sup> / R<sup>2</sup> adjusted</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;\" colspan=\"3\">0.126 / 0.118</td>\n<td style=\" padding:0.2cm; text-align:left; vertical-align:top; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;\" colspan=\"3\">0.177 / 0.167</td>\n</tr>\n\n</table>\n\n`````\n:::\n:::\n\n\n:::\n\n::: {.callout-important icon=false appearance=\"minimal\"}\n\nWe conducted a sensitivity analysis to assess how robust our conclusions were regarding outdoor time and the weekly number of social interactions in the presence of previously identified outliers and potentially influential observations. We re-fit the model, excluding these 28 observations (14% of our original sample), and compared these model results (`wb_mdl2`) to those of our original model (`wb_mdl1`). \n\nThere was little difference in the estimates from `wb_mdl1` and `wb_mdl2`, and so we can conclude that after conducting a sensitivity analysis, there were no meaningful differences in our results, and hence our conclusions from our original model hold. Specifically:\n\n+ The direction of all model estimates are the same in `wb_mdl1` and `wb_mdl2` (i.e., all positive)\n+ There is no difference in statistical significance, and the p-values were of a similar magnitude (i.e., all < .001)\n+ The estimate and confidence intervals for `outdoor_time` are very similar\n+ There are some quantitative differences in the estimate and confidence intervals for `social_int`. The estimate differs slightly in magnitude by 0.07), but given that this remains positive and significant, we do not need to be too concerned about this. \n\n:::\n\n## Bootstrapping\n\nThe bootstrap method is an alternative non-parametric method of constructing a standard error. Instead of having to rely on calculating the standard error with a formula and potentially applying fancy mathematical corrections, bootstrapping involves mimicking the idea of “repeatedly sampling from the population”. It does so by repeatedly **re**sampling with **replacement** from our original sample.\n\nWhat this means is that we don’t have to rely on any assumptions about our model residuals, because we actually generate an actual distribution that we can take as an approximation of our sampling distribution, meaning that we can actually look at where 95% of the distribution falls, without having to rely on any summing of squared deviations.\n\nNote, the bootstrap may provide us with an alternative way of conducting inference, but our model may still be mis-specified. It is also very important to remember that bootstrapping is entirely reliant on utilising our original sample to pretend that it is a population (and mimic sampling from that population). If our original sample is not representative of the population that we’re interested in, bootstrapping doesn’t help us at all.\n\n## OLS vs WLS Regression\n\nThe method of ordinary least squares regression (OLS: i.e., the type of regression model you have been fitting on the course) assumes that there is constant variance in the errors (*homoscedasticity*). The method of weighted least squares (WLS) can be used when the ordinary least squares assumption of constant variance in the errors is violated (i.e., you have evidence of *heteroscedasticity*, like we do in Q3 of this lab).\n\nIf we have some specific belief that your non-constant variance is due to differences in the variances of the outcome between various groups, then it might be better to use Weighted Least Squares.   \n\nAs an example, imagine we are looking at weight of different dog breeds (@fig-dogweight). The weights of chihuahuas are all quite close together (between 2 to 5kg), but the weight of, for example, spaniels is anywhere from 8 to 25kg - a much bigger variance. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![The weights of 49 dogs, of 7 breeds](1_b2_reading_files/figure-html/fig-dogweight-1.png){#fig-dogweight fig-align='center' width=80%}\n:::\n:::\n\n\nRecall that the default way that `lm()` deals with categorical predictors such as `dog breed`, is to compare each one to a reference level. In this case, that reference level is \"beagle\" (first in the alphabet). Looking at @fig-dogweight above, which comparison do you feel more confident in? \n\n- **A:** Beagles (14kg) vs Pugs (9.1kg). A difference of 4.9kg.  \n- **B:** Beagles (14kg) vs Spaniels (19kg). A difference of 5kg.  \n\nHopefully, your intuition is that **A** looks like a clearer difference than **B** because there's less overlap between Beagles and Pugs than between Beagles and Spaniels. Our standard linear model, however, assumes the standard errors are identical for each comparison:  \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = weight ~ breed, data = dogdf)\n...\nCoefficients:\n                      Estimate Std. Error t value Pr(>|t|)    \n(Intercept)             13.996      1.649   8.489 1.17e-10 ***\nbreedpug                -4.858      2.332  -2.084   0.0433 *  \nbreedspaniel             5.052      2.332   2.167   0.0360 *  \nbreedchihuahua         -10.078      2.332  -4.322 9.28e-05 ***\nbreedboxer              20.625      2.332   8.846 3.82e-11 ***\nbreedgolden retriever   17.923      2.332   7.687 1.54e-09 ***\nbreedlurcher             5.905      2.332   2.533   0.0151 *  \n---\n```\n:::\n:::\n\n\nFurthermore, we can see that we have heteroscedasticity in our residuals - the variance is not constant across the model:  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(dogmodel, which=3)\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/unnamed-chunk-121-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\nWeighted least squares is a method that allows us to apply weights to each observation, where the size of the weight indicates the precision of the information contained in that observation.  \n\nWe can, in our dog-breeds example, allocate different weights to each breed. Accordingly, the Chihuahuas are given higher weights (and so Chihuahua comparisons result in a smaller SE), and Spaniels and Retrievers are given lower weights. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(nlme)\nload(url(\"https://uoepsy.github.io/data/dogweight.RData\"))\ndogmod_wls = gls(weight ~ breed, data = dogdf, \n                 weights = varIdent(form = ~ 1 | breed))\nsummary(dogmod_wls)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\nCoefficients:\n                           Value Std.Error   t-value p-value\n(Intercept)            13.995640  1.044722 13.396516  0.0000\nbreedpug               -4.858097  1.271562 -3.820576  0.0004\nbreedspaniel            5.051696  2.763611  1.827933  0.0747\nbreedchihuahua        -10.077615  1.095964 -9.195207  0.0000\nbreedboxer             20.625429  1.820370 11.330351  0.0000\nbreedgolden retriever  17.922779  2.976253  6.021927  0.0000\nbreedlurcher            5.905261  1.362367  4.334559  0.0001\n```\n:::\n:::\n\n\nWe _can_ also apply weights that change according to continuous predictors (e.g. observations with a smaller value of $x$ are given more weight than observations with larger values). \n\n## Data Transformations\n\nA data transformation involves the replacement of a variable (e.g., $y$) by a function of that variable in order to change the shape of a distribution or association (e.g., to help reduce skew). We can transform the outcome variable prior to fitting the model, using something such as `log(y)` or `sqrt(y)`. This will sometimes allow us to estimate a model for which our assumptions are satisfied.\n\nSome of the most common (not an exhaustive list) transformations are:\n\n+ **Log (`log(y)`)**: Often used for reducing right skewness. Note, this transformation cannot be applied to zero or negative values (make sure to check your data!)\n+ **Square root (`sqrt(y)`)**: Also often used for reducing right skewness. This transformation can be applied to zero values (but not negative), and is commonly applied to count data\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![A model of a transformed outcome variable can sometimes avoid violations of assumptions that arise when modeling the outcome variable directly. Data from https://uoepsy.github.io/data/trouble1.csv](1_b2_reading_files/figure-html/fig-trouble1-1.png){#fig-trouble1 fig-align='center' width=80%}\n:::\n:::\n\n\nThe major downside of this is that we are no longer modelling $y$, but some transformation $f(y)$ ($y$ with some function $f$ applied to it). Interpretation of the coefficients changes accordingly, such that we are no longer talking in terms of changes in y, but changes in $f(y)$. When the transformation function used is non-linear (see the Right-Hand of @fig-logtr) a change in $f(y)$ is **not the same** for every $y$. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![The log transformation is non-linear](1_b2_reading_files/figure-html/fig-logtr-1.png){#fig-logtr fig-align='center' width=80%}\n:::\n:::\n\n\nFor certain transformations, we _can_ re-express coefficients to be interpretable with respect to $y$ itself. For instance, the model using a log transform $ln(y) = b_0 + b_1(x)$ gives us a coefficient that represents statement __A__ below. We can re-express this by taking the opposite function to logarithm, the exponent, `exp()`. Similar to how this works in logistic regression, the exponentiated coefficients obtained from `exp(coef(model))` are _multiplicative_, meaning we can say something such as statement __B__\n\n:::int\n\n- __A:__ \"a 1 unit change in $x$ is associated with a $b$ unit change in $ln(y)$\".  \n- __B:__ \"a 1 unit change in $x$ is associated with $e^b$ __percent__ change in $y$.\"\n\n:::\n\nFinding the optimal transformation to use can be difficult, but there are methods out there to help you. One such method is the BoxCox transformation, which can be conducted using `BoxCox(variable, lambda=\"auto\")`, from the __forecast__ package.^[This method finds an appropriate value for $\\lambda$ such that the transformation $(sign(x) |x|^{\\lambda}-1)/\\lambda$ results in a close to normal distribution.] \n\n## Using Non-Linear Models\n\n::: {.panel-tabset}\n\n### Generalized Linear Models\n\nGeneralized Linear Models (GLMs) can appropriately deal with data that do not follow a normal distribution (which is a requirement for traditional linear models). They can accommodate various types of distributions, including the Poisson, binomial, and gamma distributions. This makes them suitable for modelling count data (e.g., number of sunny days Edinburgh has per year - yes, count data can include 0!), binary data (where there are only two possible values e.g., doesn't wear glasses vs wear glasses, smoker vs non-smoker, i.e., values that are yes/no or 0/1), and other types of non-normal data.\n\nWe will explore some GLMs later in the course (Semester 2 Block 4), where we will work with logistic regression models. \n\n### Higher Order Terms\n\nHigher order regression terms refer to the inclusion of polynomial terms of degree higher than one in a regression model. In a linear regression model, the association between the dependent variable ($Y$) and the independent variable ($X$) is assumed to be linear, which means the association can be represented by a straight line. However, in many real-world scenarios, associations between variables are not strictly linear, and including higher order regression terms can help capture more complex relationships. Higher order terms that you could incorporate include quadratic, cubic, or higher degree polynomial terms. \n\nFor example, in a quadratic regression model, the relationship between $Y$ and $X$ can be represented as:\n\n$$\nY = \\beta_0 + \\beta_1 \\cdot X + \\beta_2 \\cdot X^2 + \\epsilon\n$$\n$$\n\\begin{align}\n& \\text{Where:} \\\\\n& Y = \\text{Dependent Variable} \\\\\n& X = \\text{Independent Variable} \\\\\n\\end{align}\n$$\n\nAs in our models we've seen so far, $\\beta_0$, $\\beta_1$, and $\\beta_2$ are the coefficients to be estimated in the above model. What is different from what we've seen in DAPR2 is the term $\\beta_2 \\cdot X^2$, and this represents the *quadratic term*. This allows for a curved as opposed to straight line to represent the association between $Y$ and $X$, and hence can allow us to capture more complex relationships. For example, we can model the association between height and age:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Two linear models, one with a quadratic term (right)](1_b2_reading_files/figure-html/fig-nonlin-1.png){#fig-nonlin fig-align='center' width=100%}\n:::\n:::\n\n\nPlease note that these types of models are beyond the scope of the DAPR2 course, but if you want to know more, please do read up on these in your own time. \n:::\n\n## Removing Observations\n\nRemoving outliers and potentially influential observations should be a last resort - not all outliers are inherently 'bad' - we do expect natural variation in our population(s) of interest. Outliers can be informative about the topic under investigation, and this is why you need to be very careful about excluding outliers due only to their 'extremeness'. In doing so, you can distort your results by removing variability - i.e., by forcing the data to be more normal and less variable than it actually is, and reduce statistical power by reducing the size of your sample. \n\nIf you do decide to remove observations, you will need to document what specific data points you excluded, and provide an explanation as to why these were excluded. \n\nTo set specific values to `NA` in our dataset (and save this updated dataset in a new object named `mwdata2`), we could use the following code. For the purpose of this demonstration, lets say that we wanted to set any `age` values of <20 as `NA`. In the original dataset `mwdata`, we had 3 individuals aged 18, and 6 aged 19, so we should end up with 9 `NA` values in `mwdata2` column `age`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#specify age column in original dataset, where age is < 20, for values to be set to NA and save to new object named mwdata2 to avoid overwriting original data\nmwdata2 <-  mwdata |> \n    mutate(age = replace(age, age < 20, NA))\n\n#check how many NA values we have - there should be 9 (so 9 TRUEs):\ntable(is.na(mwdata2$age))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE \n  191     9 \n```\n:::\n:::\n\n\nIf we wanted to remove a full row from the datset, we could use the following code. For the purpose of this demonstration, lets say that we wanted to remove all rows that were highlighted in the above assumption and diagnostic checks as potentially having an adverse influence on our model estimates:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create new dataset 'mwdata3' without (by specifying -) identified outliers and potentially influential observations\nmwdata3 <- mwdata[-c(16, 25, 50, 53, 56, 58, 59, 60, 62, 72, 73, 75, 76, 78, 79, 85, 101, 109, 125, 126, 127, 131, 149, 151, 159, 163, 165, 169, 173, 176, 179, 197), ]\n\n# check dimensions - should now have 32 rows less than original dataset 200 - 32 = 168\ndim(mwdata3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 168   7\n```\n:::\n:::\n\n\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# Bootstrap\n\nThe _bootstrap_ is a general approach to assessing whether the sample results are statistically significant or not, and allows us to draw inferences to the population from a regression model. This method is assumption-free and does not rely on conditions such as normality of the residuals.\n\nIt is based on sampling repeatedly with replacement (to avoid always getting the original sample exactly) from the data at hand, and then computing the regression coefficients from each re-sample. We will equivalently use the word \"bootstrap sample\" or \"resample\" (for **sample** with **re**placement).\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-74' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-74', 'opt-start-74')\"> <span class=\"olab\">Overview</span></span></div><div class=\"optional-body\" id = \"opt-body-74\" style=\"display: none;\">\n\n\n\nThe basic principle is:\n\n<center>\n__The population is to the original sample__\n\n__as__\n\n__the original sample is to the bootstrap samples.__\n\n</center>\n\n\nBecause we only have one sample of size $n$, and we do not have access to the data for the entire population, we consider our original sample as our best approximation to the population. \n\nTo be more precise, we assume that the population is made up of many, many copies of our original sample. Then, we take multiple samples each of size $n$ from this assumed population. This is equivalent to sampling _with replacement_ from the original sample.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/reg-boot.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-75' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-75', 'opt-start-75')\"> <span class=\"olab\">Terminology</span></span></div><div class=\"optional-body\" id = \"opt-body-75\" style=\"display: none;\">\n\n\n\n- A _parameter_ is a numerical summary for the population, e.g. the population slope $\\beta_1$.\n- A _statistic_ is a numerical summary calculated from the sample data, e.g. the estimated slope in the sample $\\widehat \\beta_1$. We use the sample statistic as a best guess, or estimate, for the unknown population parameter.\n- A _bootstrap sample_ is chosen with replacement from an existing sample, using the same sample size.\n- A _bootstrap statistic_ is a statistic computed for each bootstrap sample.\n- A _bootstrap distribution_ collects bootstrap statistics for many bootstrap samples.\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-76' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-76', 'opt-start-76')\"> <span class=\"olab\">In R</span></span></div><div class=\"optional-body\" id = \"opt-body-76\" style=\"display: none;\">\n\n\n\nFollow these steps:\n\n* 1: Load the **car** package.    \n  \n* 2: Use the `Boot()` function (do not forget the uppercase B!) which takes as arguments:\n    - the fitted model\n    - `f`, saying which bootstrap statistics to compute on each bootstrap sample. By default `f = coef`, returning the regression coefficients.\n    - `R`, saying how many bootstrap samples to compute. By default `R = 999` but this could be any number. To experiment we recommend 1000, when you want to produce results for journals, it is typical to go with 10,000 or more.\n    - `ncores`, saying if to perform the calculations in parallel (and more efficiently). However, this will depend on your PC, and you need to find how many cores you have by running `parallel::detectCores()` on your PC. By default the function uses `ncores = 1`.  \n     \n* 3: Run the code. However, please remember that the `Boot()` function does **not** want a model which was fitted using data with `NAs`. To remove, for example, you could use `na.omit`.  \n  \n* 4: Look at the `summary()` of the bootstrap results. When doing so the output will show, for each regression coefficient, the value in the original sample in the column `original`, and in the `bootSE` column, the estimate of the variability of the coefficient from bootstrap sample to bootstrap sample. The `bootSE` provides us the bootstrap standard error, or bootstrap SE in short. We can use this to answer the key question of how accurate our estimate is. \n  \n* 5: Compute confidence intervals via the `Confint()` function. Use your preferred confidence level (usually, and by default, 95%) by specifying `level = `. If you select 95% confidence intervals, by also specifying the `type = \"perc\"` argument, `R` will return the values that comprise 95% of all values in between them, i.e. the value with 2.5% of observations below it and the value with 2.5% of observations above it and 97.5% of observations below it.  \n  \n* 6: Provide interpretation in the context of your research question and report results in APA format. *(Note: the actual estimates are those from our original model, it is just the bounds of the interval that bootstrapping is providing us with)*. \n\n:::blue\n\n**In R**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#specify model\nrecall_mdl <- lm(recall_accuracy ~ recall_confidence + age, data = recalldata)\n\n#step 1: load car package\nlibrary(car)\n\n#step 2/3: bootstrap model (asking to resample 1000 times, i.e., getting a distribution of 1000 values for the coefficients)\nbootmymodel <- Boot(recall_mdl, R = 1000)\n\n#step 4: check summary\nsummary(bootmymodel)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nNumber of bootstrap replications R = 1000 \n                  original   bootBias   bootSE  bootMed\n(Intercept)       36.15959 -3.2711632 16.47382 34.86127\nrecall_confidence  0.89573  0.0522770  0.25721  0.92141\nage               -0.33916  0.0027399  0.11400 -0.32973\n```\n:::\n\n```{.r .cell-code}\n#step 5: confidence intervals\nConfint(bootmymodel, level = 0.95, type = \"perc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBootstrap percent confidence intervals\n\n                    Estimate      2.5 %     97.5 %\n(Intercept)       36.1595862 -1.0225793 61.5221101\nrecall_confidence  0.8957292  0.5188793  1.5129003\nage               -0.3391577 -0.5824887 -0.1458007\n```\n:::\n:::\n\n\n:::\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<br> \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-77' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-77', 'opt-start-77')\"> <span class=\"olab\">Visualisation</span></span></div><div class=\"optional-body\" id = \"opt-body-77\" style=\"display: none;\">\n\n\n\nYou can visualise the uncertainty in the estimates by plotting histograms using the built-in function from the **car** package, which simply takes the bootstrap results `bootmymodel`. The bootstrap distribution should appear to be normal, and if non-normal, results are likely untrustworthy (note the distribution can be somewhat ambiguous with a small number of resamples). \n\n:::blue\n\n**In R**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhist(bootmymodel, ci = \"perc\", legend = \"separate\")\n```\n\n::: {.cell-output-display}\n![](1_b2_reading_files/figure-html/eval-1.png){fig-align='center' width=80%}\n:::\n:::\n\n\n:::\n\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n<div class=\"divider div-transparent div-dot\"></div>\n\n# General Formatting & Presenting of Results\n\n## LaTeX Symbols & Equations\n\nBy embedding LaTeX into RMarkdown, you can accurately and precisely format mathematical expressions, ensuring that they are not only technically correct but also visually appealing and easy to interpret.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-78' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-78', 'opt-start-78')\"> <span class=\"olab\">LaTeX Guide</span></span></div><div class=\"optional-body\" id = \"opt-body-78\" style=\"display: none;\">\n\n\n\nFor an overview of how to integrate LaTeX symbols and equations, review [Lesson 9 of the RMD bootcamp](https://uoepsy.github.io/scs/rmd-bootcamp/09-latex.html). \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n  \n## APA Formatting\n\nAPA format is a writing/presentation style that is often used in psychology to ensure consistency in communication. APA formatting applies to all aspects of writing - from formatting of papers (including tables and figures), citation of sources, and reference lists. This means that it also applies to how you present results in your Psychology courses, including DAPR2.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-79' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-79', 'opt-start-79')\"> <span class=\"olab\">APA Formatting Guides</span></span></div><div class=\"optional-body\" id = \"opt-body-79\" style=\"display: none;\">\n\n\n\nAll results should be presented following [APA guidelines](https://apastyle.apa.org/instructional-aids/numbers-statistics-guide.pdf). \n\nYou also need to follow APA style rules for [tables and figures](https://apastyle.apa.org/style-grammar-guidelines/tables-figures). \n\nMake sure to familiarise yourself with the above guides, and practice presenting your results following these rules.\n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Tables\n\nWe want to ensure that we are presenting results in a well formatted table. To do so, there are lots of different packages available (see [Lesson 4 of the RMD bootcamp](https://uoepsy.github.io/scs/rmd-bootcamp/04-prettytab.html)). \n\nOne of the most convenient ways to present results from regression models is to use the `tab_model()` function from **sjPlot**.\n\n\n\n<div class=\"optional-begin\"><span id='opt-start-80' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-80', 'opt-start-80')\"> <span class=\"olab\">Creating tables via tab_model</span></span></div><div class=\"optional-body\" id = \"opt-body-80\" style=\"display: none;\">\n\n\n\nWithin `tab_model()`, there are lots of different ways that you can customise your table. The most common arguments that you should use are `dv.labels`, `pred.labels`, and `title`. \n\nYou can rename your DV and IV labels by specifying `dv.labels` and `pred.labels`. To do so, specify your variable name on the left, and what you would like this to be named in the table on the right. For `title`, you can simply specify in \"\"'s what you want your title to be e.g., `title = \"This is my title\"`. \n\nHere's an example if I had fitted a model with the following information:\n\n- Model name = `mdl_test`\n- Model DV = `cognitive_score`\n- Model IVs = `SES` and `age`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmdl_test <- lm(cognitive_score ~ SES + age, data = data_name)\n```\n:::\n\n\nI want to change the names of `SES` and `age` to be `socio-economic status` and `age - in years` respectively. What we need to pay attention to here is the ordering of the IVs - the ordering in our `lm()` must match that in `tab_model()`. I also want to name my table *Regression Table for Cognitive Scores Model*. Here is how we would do this in **R**:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sjPlot)\ntab_model(mdl_test,\n          pred.labels = c('Intercept', 'socio-economic status', 'age - in years'),\n          title = \"Regression Table for Cognitive Scores Model\")\n```\n:::\n\n\nSee [here](https://uoepsy.github.io/scs/rmd-bootcamp/zz-packs.html) for another short example. \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n\n## Cross Referencing\n\nCross-referencing is a very helpful way to direct your reader through your document, and the good news is that this can be done automatically in RMarkdown. \n\n\n\n<div class=\"optional-begin\"><span id='opt-start-81' class=\"fa-solid fa-circle-right optional-icon clickable\" onclick=\"toggle_visibility('opt-body-81', 'opt-start-81')\"> <span class=\"olab\">Cross Referencing</span></span></div><div class=\"optional-body\" id = \"opt-body-81\" style=\"display: none;\">\n\n\n\nThere are three key components to allow you to successfully cross-reference within your RMarkdown document:\n\n+ A bookdown output format\n+ A caption to your figure or table\n+ A named/labeled code chunk\n\nOnce you have the above, you will be able to cross-reference using the syntax \\@ref(type:label), where label is the chunk name/label,  and type is the environment being referenced (e.g. tab for table, fig for figure, etc.).\n\nFor an in-depth overview and example of how to cross-reference, see [Lesson 7 of the RMD bootcamp](https://uoepsy.github.io/scs/rmd-bootcamp/07-refs.html). \n\n\n\n</div><p class=\"optional-end\"></p>\n\n\n",
    "supporting": [
      "1_b2_reading_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/htmlwidgets-1.6.2/htmlwidgets.js\"></script>\r\n<script src=\"site_libs/plotly-binding-4.10.2/plotly.js\"></script>\r\n<script src=\"site_libs/typedarray-0.1/typedarray.min.js\"></script>\r\n<script src=\"site_libs/jquery-3.5.1/jquery.min.js\"></script>\r\n<link href=\"site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\r\n<link href=\"site_libs/plotly-htmlwidgets-css-2.11.1/plotly-htmlwidgets.css\" rel=\"stylesheet\" />\r\n<script src=\"site_libs/plotly-main-2.11.1/plotly-latest.min.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}